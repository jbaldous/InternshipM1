---
title: "cohort_metadata"
author: "Jules Baldous"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = FALSE, error = TRUE)
rm(list = ls())

load(file="metadata.RData")
load(file="cohort.RData")
```

Alt + O pour replier tout et ouvrir que ce qui est pertinent.

**Package nécessaires à l'exécution de ce document :**

```{r package}
library(dplyr)
library(gtsummary)
library(GGally)
library(ggplot2)
library(FactoMineR)
library(factoextra)
library(plotly)
library(corrplot)
library(scales)
library(psych)
library(pheatmap)
library(pvclust)
library(ggpmisc)
library(ggbeeswarm)
library(MASS)
library(car)
library(tidyr)
library(gt)
library(grid)
library(gridExtra)
library(cowplot)
library(MuMIn)
library(lme4)
library(lmerTest)
library(pscl)
library(ggstats)
library(lubridate)
library(purrr)
library(vegan)
library(ggpubr)
library(tibble)
library(parallel)
library(parameters)
```

# Traitement des données 

Chaque souche est dans un hôte et fait donc face à un environnement différent. On va donc associer chaque caractéristiques hôtes à chaque souche. Pour cela on crée un nouveau dataframe `longitudinal_strain_host`.

```{r traitement}
longitudinal_strain_host <- longitudinal_strain

# Ajout des variables de manière vectorisée (je ne connaissais, GPT me l'a optimisé comme ça)

vars <- c("regime", "score_epices", "sex", "age", "taille_cm", "poids", "code_postal", "pays_de_naissance", "voie_accouchement", "allaitement", "nombre_foyer", "nombre_enfants", "sport_frequence", "age_group", "foyer_group", "precarity_group", "ville_group", "sport_group")


for (var in vars) {
  longitudinal_strain_host[[var]] <- metadata[[var]][longitudinal_strain_host$host]
}

longitudinal_strain_host$regime <- as.numeric(longitudinal_strain_host$regime)

# On ajoute les antibiotiques
prise_antibio <- rep(FALSE, 421)

longitudinal_strain_host$prise_antibiotique <- prise_antibio 

for (strain in longitudinal_strain_host$id.clone) {
  if (longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "host"] %in% antibiotique$record_id) {
    if (longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "date_max"] >= min(antibiotique[antibiotique$record_id == as.numeric(longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "host"]), "date_traitement"])) {
      longitudinal_strain_host[longitudinal_strain_host$id.clone == strain,]$prise_antibiotique <- TRUE}
    }
}

# On ajoute les voyages
longitudinal_strain_host$voyage_event <- prise_antibio 

for (strain in longitudinal_strain_host$id.clone) {
  if (longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "host"] %in% voyage$record_id) {
    if (longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "date_max"] >= min(voyage[voyage$record_id == as.numeric(longitudinal_strain_host[longitudinal_strain_host$id.clone == strain, "host"]), "date_voyage"])) {
      longitudinal_strain_host[longitudinal_strain_host$id.clone == strain,]$voyage_event <- TRUE}
    }
}
```

On va scale par le temps moyen des souches résidentes en fonction de leur phylogroupes. Ceci permettra de gommer l'effet phylogroupe dont on sait qu'il explique une grande partie de la résidence. 

```{r residency_scale}
longitudinal_strain_host <- longitudinal_strain_host %>%
  group_by(group) %>% # On groupe par phylogroupe
  mutate(residency_scaled_groups = as.numeric(residency/mean(residency))) %>%
  ungroup()
```

On va aussi log-scale pour exacerber les différences entre souches transientes et rendre la distribution des temps de résidences plus symétriques.

```{r residency_log_scale}
longitudinal_strain_host <- longitudinal_strain_host %>%
  group_by(group) %>% # On groupe par phylogroupe
  mutate(residency_scaled_log_groups = log(residency_scaled_groups + 1)) %>%
  ungroup()
```

# Résidence et déterminants hôtes / bactériens

## Visualisation des relations entre la résidence (temps et statut) et les déterminants hôtes / bactériens

On va être amené à séparer les souches résidentes de toutes (résidentes + transientes) les souches. Cette séparation ne permet pas de juste observer l'effet sur la longueur des temps de résidence car on oublie les souches transientes qui jouent un rôle dans la longueur (en baissant les temps). Ainsi, quand on sépare les résidentes c'est plus pour voir si l'effet du facteur sur les temps de résidence est une sélection des transientes (pas de cohérence entre les deux plots) ou si c'est vraiment le temps de résidence brut (cohérence entre les deux plots) qui est affecté.

### Visualisation des distributions des temps de résidence

On s'intéresse d'abord à la distribution des temps de résidences.

```{r distrib_residency}
plot_distrib_residency <- ggplot(longitudinal_strain_host, aes(x = residency)) + 
  geom_histogram(bin = 30) +
  theme_bw() + 
  xlab("residency")

plot_distrib_residency
```

On s'intéresse aussi aux temps de résidences scalés.

```{r distrib_residency_scaled}
plot_distrib_residency_scaled <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups)) + 
  geom_histogram(bin = 30) +
  theme_bw() + 
  xlab("residency")

plot_distrib_residency_scaled
```

On s'intéresse aussi aux temps de résidences log-scalés.

```{r distrib_residency_log_scaled}
plot_distrib_residency_log_scaled <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups)) + 
  geom_histogram(bin = 15) +
  theme_bw() + 
  xlab("residency")

plot_distrib_residency_log_scaled
```

### Résidence et déterminants bactériens

On va s'intéresser à la densité globale, la densité focale et le phylogroupe.

On compare à chaque fois, pour chaque phylogroupe, les différents scaling et avec les souches résidentes ou non. On représente aussi la corrélation pour toutes les souches quelque soit le phylogroupe.

#### Résidence et densité focale
##### Pas par phylogroupe

On représente la corrélation pour toutes les souches entre résidence et densité focale.

```{r residency_self_density_correlation, fig.height=40, fig.width=40}
plot_residency_dens_self <- ggplot(longitudinal_strain_host, aes(x = residency, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

plot_residency_resident_dens_self <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(plot_residency_dens_self, p2, p3, plot_residency_resident_dens_self, p5, p6, ncol=3)
```

On observe une corrélation positive significative entre les temps de résidence et la densité de chaque souche dans l'intestin. Quand on enlève les souches transientes cette corrélation semble plus faible.

Voyons si il y a une différence de moyenne entre les densités propres entre souches transientes et résidentes avec un boxplot.

```{r residency_self_density_boxplot}
plot_residency_status_dens_self <- ggplot(longitudinal_strain_host, aes(x = resident_status, y = log.dens.self, fill = as.factor(resident_status))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = resident_status), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Densité Focale")

plot_residency_status_dens_self
```

Les souches résidentes semblent plus denses dans l'intestin. Ceci est logique puisque les souches résidentes sont celles qui ont réussi à établir des colonies suffisamment denses pour ne pas se faire éliminer par le transit.

Ainsi, la corrélation positive entre la résidence et la densité propre de chaque souche provient probablement de la différence entre souche résidente et transiente (car elle n'est pas présente si on considère seulement les souches résidentes).

Elle est la résultante de l'installation dans l'intestin des souches résidentes et donc à la formation de colonies denses. En effet, à chaque sample la densité focale est calculée comme la proportion que prend la souche fois la densité globale en E. coli. Ceci nous indique que le souches résidentes étaient celles qu'on observe le plus en proportion dans chaque sample par rapport aux transientes. Ceci va dans le sens d'un effet d'installation entre transiente et résidente.

L'effet du facteur log.dens.self est donc la résultante de l'installation dans l'intestin des colonies de résidentes, comparées aux transientes.

##### Par phylogroupe

Voyons si la corrélation trouvée globalement est la même dans chaque phylogroupe. On pourrait tout à fait imaginer des stratégies différentes entre phylogroupe vis à vis de la résidence.

```{r residency_self_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Corrélation positive chez toutes les phylogroupes entre la résidence avec la densité de chaque souche. Ceci confirme que les souches qui restent longtemps sont celles qu'on observe en plus grande densité dans l'intestin. Pourrait venir de la façon dont on sample, puisqu'on récupère les souches les plus denses.

Si on considère que les souches résidentes on observe certains phylogroupes qui ont des corrélations négatives entre temps de résidence et densité focale (densité de la souche en elle même). Notamment A1... A creuser ? A.1 a majoritairement des transients (qui suivent donc des stratégies de transient) et donc les souches qui restent longtemps ne suivent pas la même stratégie que celles qui restent longtemps car résidentes.

#### Résidence et densité globale

On s'intéresse maintenant à l'influence de la densité totale de l'intestin où évolue chaque souche avec leur temps de résidence.

##### Pas par phylogroupe

```{r residency_global_density_correlation, fig.height=40, fig.width=40}
plot_residency_dens_glob <- ggplot(longitudinal_strain_host, aes(x = residency, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

plot_residency_resident_dens_glob <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(plot_residency_dens_glob, p2, p3, plot_residency_resident_dens_glob, p5, p6, ncol=3)
```

On observe une corrélation positive entre la densité totale et les temps de résidence quand on considère toutes les souches. Si on ne considère que les résidents il n'y a aucune corrélation. 

Ceci fait donc penser à un effet de choix entre résident et transient de la densité globale plutôt que sur les temps de résidence en eux mêmes.

Vérifions le avec un boxplot.

```{r residency_global_density_boxplot}
plot_residency_status_dens_glob <- ggplot(longitudinal_strain_host, aes(x = resident_status, y = log.density, fill = as.factor(resident_status))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = resident_status), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Densité Globale")

plot_residency_status_dens_glob
```

Les souches résidentes sont plutôt dans des intestins avec de fortes densités de E. coli. Ceci pourrait venir du fait que comme on trouve une résidente, celle ci a une grande densité propre et donc ceci influence la densité globale vers le haut.

##### Par phylogroupe

```{r residency_global_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Globalement les phylogroupes ont plutôt des corrélations positives. Quand on distingue les résidents des transients on a des corrélations négatives qui apparaissent selon les phylogroupes.

#### Résidence et phylogroupe 

On sait que certains phylogroupes sont résident et d'autres transient. On s'attend donc à avoir une relation entre la résidence et les phylogroupes. On ne considère que les temps de résidence et pas ceux scalés. On fait la différence entre toutes les souches et les souches résidentes.

```{r residency_phylogroup_boxplot}
plot_residency_phylogroup <- ggplot(longitudinal_strain_host, aes(x = group, y = residency, fill = as.factor(group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Phylogroupe")

plot_residency_resident_phylogroup <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = group, y = residency, fill = as.factor(group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Phylogroupe pour Résident")

grid.arrange(plot_residency_phylogroup, plot_residency_resident_phylogroup, ncol=1)
```

On observe que les temps de résidence changent drastiquement en fonction du phylogroupe. Certains phylogroupes (A.2, B2.3, D.1 et F) ont des moyennes plus hautes que le treshold de résidence (14 jours), ce sont les phylogroupes résidents. 

Quand on sépare les souches résidentes (plot du bas), on observe que au sein des phylogroupes résidents certains ont des souches qui restent plus longtemps que d'autres. Le phylogroupe D.1 est d'ailleurs le phylogroupe où les souches résidentes sont les plus longues en moyenne (dans notre cohorte).

On va voir si le staut de résidence est affecté par les phylogroupes. 

```{r}
plot_residency_status_phylogroup <- ggplot(longitudinal_strain_host, aes(x = as.factor(group), fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Phylogroup", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)

plot_residency_status_phylogroup
```

### Résidence et déterminants hôtes

On va s'intéresser à tous les facteurs hôtes; age, poids, taille, score EPICES, sexe, régime, ville, voie accouchement, voie d’allaitement, nombre de personnes dans le foyer, nombre d'enfants, la prise d'antibiotique, les voyages et la fréquence du sport.

On va à chaque fois différencier les trois façons de mesurer les temps de résidence et les souches résidentes de toutes les souches. On va aussi considérer les différence entre résident et transient pour chaque facteurs hôtes.

#### Résidence et Âge

##### Pas par phylogroupe 

```{r residency_age, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Il ne semble pas y a avoir de corrélation entre l'âge et les temps de résidence. Quand on enlève les souches transientes on a une meilleure corrélation.

```{r resident_age_boxplot}
ggplot(longitudinal_strain_host, aes(x = resident_status, y = age, fill = as.factor(resident_status))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = resident_status), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Age")
```
Aucune différence entre les deux groupes.

##### Par phylogroupe

```{r residency_age, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Il ne semble pas y avoir de corrélation entre l'âge et les temps de résidence même pour chaque phylogroupe.

##### Classification en âge

Pour augmenter la puissance de la variable âge on l'a catégorisé.

```{r age_group_residency, fig.height=20, fig.width=20}
plot_age_residence_1 <- ggplot(longitudinal_strain_host, aes(x = age_group, y = residency, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Age")

plot_age_residence_3 <- ggplot(longitudinal_strain_host, aes(x = age_group, y = residency_scaled_groups, fill = age_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Age")

plot_age_residence_2 <- ggplot(longitudinal_strain_host, aes(x = age_group, y = residency_scaled_log_groups, fill = age_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Age")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = age_group, y = residency, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Age pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = age_group, y = residency_scaled_groups, fill = age_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Age pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = age_group, y = residency_scaled_log_groups, fill = age_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Age pour Résident")


grid.arrange(plot_age_residence_1, plot_age_residence_2, plot_age_residence_3, p4, p5, p6, ncol=3)
```

La résidence semble en moyenne un peu plus faible chez les personnes de moins de 40 ans.

```{r}
plot_residency_status_age <- ggplot(longitudinal_strain_host, aes(x = as.factor(age), fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Age", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)

plot_residency_status_age_group <- ggplot(longitudinal_strain_host, aes(x = as.factor(age_group), fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Age", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)

grid.arrange(plot_residency_status_age, plot_residency_status_age_group)
```



#### Résidence et Score EPICES

##### Pas par phylogroupe

```{r residency_epices, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p")))

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p")))

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Pas de corrélation entre la précarité et les temps de résidence des souches.

##### Par phylogroupe

```{r residency_epices_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p")))

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p")))

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Aucune corrélation significative entre le score EPICES et les temps de résidence. Ce sera probablement pas une variable hôte très intéressante.

#### Résidence et Régime Alimentaire

##### Tout le régime

```{r residency_diet, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = regime, y = residency, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Diet")

p2 <- ggplot(longitudinal_strain_host, aes(x = regime, y = residency_scaled_groups, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Diet")

p3 <- ggplot(longitudinal_strain_host, aes(x = regime, y = residency_scaled_log_groups, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Diet")

diet_residency_1 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = regime, y = residency, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Diet pour Résident")

diet_residency_3 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = regime, y = residency_scaled_groups, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Diet pour Résident")

diet_residency_2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = regime, y = residency_scaled_log_groups, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Diet pour Résident")

grid.arrange(p1, p2, p3, diet_residency_1, diet_residency_3, diet_residency_2, ncol=3)
```

Les différents régimes semblent affecter quelque peu la résidence. Par exemple le régime faible en fibre (en rouge) semble associé avec plus de souches transientes que les autres. Mais les souches résidentes d'hôtes ayant le régime faible en fibre ont des temps de résidence plus longs que les autres régimes. Ce régime semble donc sélectionner des phylogroupes transients et des phylogroupes très résidents avec peu de prévalence dans l'environnement.

Voyons si le statut de résidente / transiente est affectée par le régime.

```{r resident_diet}
plot_residency_status_regime <- ggplot(longitudinal_strain_host, aes(x = as.factor(regime), fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Regime", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)

plot_residency_status_regime
```

Effectivement, il y a plus de souches transientes chez les hôtes ayant le régime bas en fibre (à gauche).

Le régime semble donc être une variable intéressante à considérer dans les modèles sur la résidence.

##### Consommation de lait et résidence

On sait que E. coli est capable de métaboliser le lait grâce à son opéron lactose. Les adultes ne sont pas évolutivement parlant destiné à se nourrir de lait. Dans nos sociétés c'est le cas, il est donc intéressant de voir si la consommation de lait favorise la résidence de certaines souches.

```{r lait_résidence, fig.height=20, fig.width=20}
longitudinal_strain_host_lait <- longitudinal_strain

# Ajout des variables de manière vectorisée (je ne connaissais, GPT me l'a optimisé comme ça)

vars <- c("regime", "lait")


for (var in vars) {
  longitudinal_strain_host_lait[[var]] <- metadata[[var]][longitudinal_strain_host_lait$host]
}

longitudinal_strain_host_lait$regime <- as.numeric(longitudinal_strain_host_lait$regime)

longitudinal_strain_host_lait <- longitudinal_strain_host_lait %>%
  group_by(group) %>% # On groupe par phylogroupe
  mutate(residency_scaled_groups = as.numeric(residency/mean(residency))) %>%
  ungroup()

longitudinal_strain_host_lait <- longitudinal_strain_host_lait %>%
  group_by(group) %>% # On groupe par phylogroupe
  mutate(residency_scaled_log_groups = log(residency_scaled_groups + 1)) %>%
  ungroup()

longitudinal_strain_host_lait$lait = as.factor(longitudinal_strain_host_lait$lait)

p1 <- ggplot(longitudinal_strain_host_lait, aes(x = lait, y = residency, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Conso Lait")

p2 <- ggplot(longitudinal_strain_host_lait, aes(x = lait, y = residency_scaled_groups, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Conso Lait")

p3 <- ggplot(longitudinal_strain_host_lait, aes(x = lait, y = residency_scaled_log_groups, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Conso Lait")

p4 <- ggplot(longitudinal_strain_host_lait[longitudinal_strain_host_lait$resident_status,], aes(x = lait, y = residency, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Conso Lait pour Résident")

p5 <- ggplot(longitudinal_strain_host_lait[longitudinal_strain_host_lait$resident_status,], aes(x = lait, y = residency_scaled_groups, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Conso Lait pour Résident")

p6 <- ggplot(longitudinal_strain_host_lait[longitudinal_strain_host_lait$resident_status,], aes(x = lait, y = residency_scaled_log_groups, fill = lait)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = lait), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Conso Lait pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

La consommation de lait ne semble pas affecter les temps de résidence.

#### Résidence et Sexe

```{r residency_sex, fig.height=20, fig.width=20}
longitudinal_strain_host$sex = as.factor(longitudinal_strain_host$sex)

p1 <- ggplot(longitudinal_strain_host, aes(x = sex, y = residency, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sexe")

p2 <- ggplot(longitudinal_strain_host, aes(x = sex, y = residency_scaled_groups, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sexe")

plot_logresidency_sex <- ggplot(longitudinal_strain_host, aes(x = sex, y = residency_scaled_log_groups, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sexe")

plot_sex_residence_1 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sex, y = residency, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sexe pour Résident")

plot_sex_residence_3 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sex, y = residency_scaled_groups, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sexe pour Résident")

plot_logresidency_resident_sex <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sex, y = residency_scaled_log_groups, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sexe pour Résident")

grid.arrange(p1, p2, p3, plot_sex_residence_1, plot_sex_residence_3, plot_logresidency_resident_sex, ncol=3)
```

Les femmes (2) semblent avoir des souches avec des temps de résidence plus longs, mais plutôt quand on corrige pour les phylogroupes. Ceci est aussi le cas pour les souches résidentes uniquement (et toujours quand on corrige pour les phylogroupes.).

Voyons plus en détail comment le sexe agit sur le statut de résident.

```{r resident_sex}
ggplot(longitudinal_strain_host, aes(x = sex, fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Sex", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)
```

On voit que le sexe agit vraiment sur les temps de résidence et pas sur la sélection de souches transientes ou résidente. 

L'effet hôte sexe semble intéressant pour la suite.

#### Résidence et Poids

##### Pas par phylogroupe

```{r residency_weigth, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Il ne semble pas y a voir de corrélation entre le poids et les temps de résidence.

##### Par phylogroupe

```{r residency_weigth_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

#### Résidence et Allaitement

```{r residency_allaitement, fig.height=20, fig.width=20}
longitudinal_strain_host$allaitement = as.factor(longitudinal_strain_host$allaitement)

p1 <- ggplot(longitudinal_strain_host, aes(x = allaitement, y = residency, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Allaitement")

p2 <- ggplot(longitudinal_strain_host, aes(x = allaitement, y = residency_scaled_groups, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Allaitement")

p3 <- ggplot(longitudinal_strain_host, aes(x = allaitement, y = residency_scaled_log_groups, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Allaitement")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = allaitement, y = residency, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Allaitement pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = allaitement, y = residency_scaled_groups, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Allaitement pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = allaitement, y = residency_scaled_log_groups, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Allaitement pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Les personnes non allaitées semblent avoir plus de souches transientes. Chez les souches résidentes l'allaitement réduit les temps de résidence en moyenne.

Vérifions si l'allaitement change le ratio résidente / transiente.

```{r resident_allaitement}
ggplot(longitudinal_strain_host, aes(x = allaitement, fill = resident_status)) +
  geom_bar(position = "fill") +
  labs(x = "Allaitement", y = "Proportion", fill = "Resident Status") +
  scale_y_continuous(labels = scales::percent)
```

Ce n'est pas très fort. L'allaitement ne semble pas avoir une influence énorme sur les temps de résidence des souches.

#### Résidence et Accouchement

```{r residency_accouchement, fig.height=20, fig.width=20}
longitudinal_strain_host$voie_accouchement = as.factor(longitudinal_strain_host$voie_accouchement)

p1 <- ggplot(longitudinal_strain_host, aes(x = voie_accouchement, y = residency, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Voie Accouchement")

p2 <- ggplot(longitudinal_strain_host, aes(x = voie_accouchement, y = residency_scaled_groups, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Voie Accouchement")

p3 <- ggplot(longitudinal_strain_host, aes(x = voie_accouchement, y = residency_scaled_log_groups, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Voie Accouchement")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voie_accouchement, y = residency, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Voie Accouchement pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voie_accouchement, y = residency_scaled_groups, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Voie Accouchement pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voie_accouchement, y = residency_scaled_log_groups, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Voie Accouchement pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Les gens nés par césarienne aurait plus des souches avec des temps de résidence plus élevés que les gens nés par voie basse. Mais ceci n'est pas très fort.

La voie d'accouchement ne semble pas influencer beaucoup les temps de résidence.

#### Résidence et Sport


```{r residency_sportfreq, fig.height=20, fig.width=20}
longitudinal_strain_host$sport_frequence = as.factor(longitudinal_strain_host$sport_frequence)

p1 <- ggplot(longitudinal_strain_host, aes(x = sport_frequence, y = residency, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sport")

p2 <- ggplot(longitudinal_strain_host, aes(x = sport_frequence, y = residency_scaled_groups, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sport")

p3 <- ggplot(longitudinal_strain_host, aes(x = sport_frequence, y = residency_scaled_log_groups, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sport")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_frequence, y = residency, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sport pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_frequence, y = residency_scaled_groups, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sport pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_frequence, y = residency_scaled_log_groups, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sport pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Rien ne semble se dessiner clairement quant à l'effet du sport sur les temps de résidence.

Voyons si catégoriser la fréquence en Fréquent / Non Fréquent change quelquechose.

```{r residency_sportgroup, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = sport_group, y = residency, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sport")

p2 <- ggplot(longitudinal_strain_host, aes(x = sport_group, y = residency_scaled_groups, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sport")

p3 <- ggplot(longitudinal_strain_host, aes(x = sport_group, y = residency_scaled_log_groups, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sport")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_group, y = residency, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Sport pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_group, y = residency_scaled_groups, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Sport pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_group, y = residency_scaled_log_groups, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Sport pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

La variable sport ne semble pas affecter les temps de résidence des souches.

#### Résidence et Nombre Foyer

```{r residency_foyer, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = nombre_foyer, y = residency, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Foyer")

p2 <- ggplot(longitudinal_strain_host, aes(x = nombre_foyer, y = residency_scaled_groups, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Foyer")

p3 <- ggplot(longitudinal_strain_host, aes(x = nombre_foyer, y = residency_scaled_log_groups, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Foyer")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_foyer, y = residency, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Foyer pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_foyer, y = residency_scaled_groups, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Foyer pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_foyer, y = residency_scaled_log_groups, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Foyer pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Les temps de résidence ne semblent pas affectés par le nombre de personnes dans le foyer.

#### Résidence et Taille

##### Pas par phylogroupe

```{r residency_height, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = taille_cm)) +
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Une petite corrélation négative probablement due à l'effet sexe caché via la taille (les femmes sont en moyenne plus petites que les hommes). L'effet n'a pas l'air du tout significatif.

##### Par phylogroupe

```{r residency_height_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = residency, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p3 <- ggplot(longitudinal_strain_host, aes(x = residency_scaled_log_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = residency_scaled_log_groups, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Globalement des corrélations négatives. Ajouter les phylogroupes ne changent pas grand chose.

#### Résidence et Nombre d'enfants

Cette variable est fortement influencée par l'âge. Voyons si l'effet est le même.

```{r residency_enfants, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = nombre_enfants, y = residency, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Enfants")

p2 <- ggplot(longitudinal_strain_host, aes(x = nombre_enfants, y = residency_scaled_groups, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Enfants")

p3 <- ggplot(longitudinal_strain_host, aes(x = nombre_enfants, y = residency_scaled_log_groups, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Enfants")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_enfants, y = residency, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Enfants pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_enfants, y = residency_scaled_groups, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Enfants pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_enfants, y = residency_scaled_log_groups, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Enfants pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Il y a l'air d'avoir une augmentation des temps de résidence chez les souches dans des hôtes avec au moins un enfant. On remarque celle ci quand on prend que les souches résidentes. Ceci était déjà le cas quand on considérait l'âge. 

Ainsi l'âge (via le nombre d'enfants) sélectionnerait des plus longs temps de résidence mais pas la résidence / transience.

#### Résidence et Prise d'antibiotique

```{r residency_antibio, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = prise_antibiotique , y = residency, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Antibio")

p2 <- ggplot(longitudinal_strain_host, aes(x = prise_antibiotique, y = residency_scaled_groups, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Antibio")

p3 <- ggplot(longitudinal_strain_host, aes(x = prise_antibiotique, y = residency_scaled_log_groups, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Antibio")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = prise_antibiotique, y = residency, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Antibio pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = prise_antibiotique, y = residency_scaled_groups, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Antibio pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = prise_antibiotique, y = residency_scaled_log_groups, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Antibio pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

La prise d'antibiotique ne change rien aux temps de résidence.

#### Résidence et Voyage

```{r residency_voyage, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = voyage_event , y = residency, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Voyage")

p2 <- ggplot(longitudinal_strain_host, aes(x = voyage_event, y = residency_scaled_groups, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Voyage")

p3 <- ggplot(longitudinal_strain_host, aes(x = voyage_event, y = residency_scaled_log_groups, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Voyage")

p4 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voyage_event, y = residency, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence et Voyage pour Résident")

p5 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voyage_event, y = residency_scaled_groups, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Residence scaled et Voyage pour Résident")

p6 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voyage_event, y = residency_scaled_log_groups, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("log-Residence et Voyage pour Résident")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
```

Le fait d'avoir fait un voyage semble légèrement augmenter les temps de résidence des souches résidentes. Il agirait donc sur la sélection de souches qui restent plus longtemps. Peut être qu'en fonction de la destination l'effet est autre. A creuser...

## Modèles linéaires pour les temps de résidence

Régression linéaire multiple mixte : On va étudier l'effet des facteurs hôte sur le phénotype "Temps de résidence dans l'hôte" de chaque souche avec une régression multiple avec un effet mixte hôte (car chaque souche est tiré d'un hôte et donc que plusieurs souches viennent d'un hôte).

On a vu que certaines corrélations étaient plus fortes quand on considère que les souches résidentes. On va donc considérer les temps de résidence en considérant toutes les souches ou seulement les résidentes.

On va aussi réaliser ces régressions sur deux variables à prédire : les temps de résidence brut et les temps de résidence log-scaled.

Nous n'avons pas incorporé en premier d'effets mixtes car aucun des effets mixtes n'a jamais été significatif pour aucun modèle considéré dans la suite. Ne pas ajouter d'effet mixte simplifie grandement la complexité des opérations. J'ai quand même ajouté une petite partie avec une sélection de modèle avec effet mixte pour améliorer la robustesse.

### Pour toutes les souches 

#### Temps de résidence

##### Régression linéaire multiple sans effet mixte

###### Selection par stepAIC

On peut commencer par une régression linéaire multiple et une sélection de modèle par stepAIC(). Cette méthode n'explore pas tous les modèles mais nous donne un premier aperçu rapide des déterminants des temps de résidence brut pour toutes les souches. 

```{r residency_all_lm}
#On utilise qu'une partie du df :
lm_df_residency <- longitudinal_strain_host

lm_df_residency <- na.omit(lm_df_residency)

lm_df_residency$date_min <- NULL
lm_df_residency$date_max <- NULL
lm_df_residency$dates_samples <- NULL
lm_df_residency$resident_status <- NULL
lm_df_residency$mlva <- NULL
lm_df_residency$residency_scaled_groups <- NULL
lm_df_residency$residency_scaled_log_groups <- NULL
lm_df_residency$host <- NULL
lm_df_residency$id.clone <- NULL
lm_df_residency$time_since_start <- NULL
lm_df_residency$time_max <- NULL

lm_df_residency$density <- NULL
lm_df_residency$dens.self <- NULL

#Soit on utilise les catégories soit les variables plus précises:
lm_df_residency$code_postal <- NULL
#lm_df_residency$ville_group <- NULL

lm_df_residency$age <- NULL
#lm_df_residency$age_group <- NULL

lm_df_residency$score_epices <- NULL
#lm_df_residency$precarity_group <- NULL

lm_df_residency$sport_frequence <- NULL
#lm_df_residency$sport_group <- NULL

#lm_df_residency$nombre_foyer <- NULL
lm_df_residency$foyer_group <- NULL

lm_df_residency$taille_cm <- scale(lm_df_residency$taille_cm)
lm_df_residency$poids <- scale(lm_df_residency$poids)

residency_lm_1 <- lm(residency ~ ., data = lm_df_residency)

summary(residency_lm_1)

#stepAIC(residency_lm_1, direction = "both")

best_lm_residency <- lm(formula = residency ~ group + log.density + log.dens.self + 
    sex + voyage_event, data = lm_df_residency)

summary(best_lm_residency)

reg_residency_unsc <- Anova(best_lm_residency)

reg_residency_unsc
```

Le meilleur modèle par selection via stepAIC montre un effet des trois facteurs bactériens et du facteur hôte Sexe et Voyage. Celui ci, d'après les coeffs de la régressions prone une résidence plus faible chez les hommes.

###### Sélection exhaustive par dredge

On fait une sélection de tous les modèles ayant 8 déterminants (improbable qu'il y en ait plus) et avec nos 3 déterminants bactériens sorti dans la sélection par stepAIC.

Ceci va permettre de voir si on a congruence entre la méthode forward/backward de notre stepAIC et la méthode dredge. Ceci permet d'être sur de la sélection de notre modèle et d'explorer d'autres modèles potentiellement compétitifs.

```{r residency_all_lm_exaustive}
#Selection du meilleur modèle :
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_residency_lm <- dredge(residency_lm_1, m.lim = c(0, 6), fixed = c("log.density","log.dens.self", "group"), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# Meilleur modèle
best_lm_residency <- lm(formula = residency ~ group + log.density + log.dens.self + 
    sex + voyage_event, data = lm_df_residency) #3939.131

summary(best_lm_residency)
Anova(best_lm_residency)
```

Le meilleur modèle sélectionné par dredge est le même que celui par stepAIC. Il y a bien congruence. Un autre modèle était compétitif : celui incluant en plus le nombre de personnes dans le foyer. Le nombre dans le foyer pourrait être corrélée à l'âge ?

##### Régression linéaire multiple avec effet mixte

On va incorporer un effet mixte et faire une sélection de modèle avec cet effet mixte toujours présent (ainsi que les trois facteurs bactériens sortant dans le meilleur lm). Ceci va permettre de rendre encore plus robustes nos résultats et de voir s'il y a changement.

```{r residency_lmm}
df_clean <- na.omit(longitudinal_strain_host)

# #Selection du meilleur lmm
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_residency_lmm <- dredge(lmer(residency ~ group + log.density + log.dens.self + regime + precarity_group + sex + age_group + taille_cm + poids + voie_accouchement + allaitement + nombre_foyer + nombre_enfants + sport_group + ville_group + prise_antibiotique + voyage_event + (1 | host), data = df_clean, REML=FALSE)
#   , m.lim = c(0, 8), fixed = c("log.density","log.dens.self", "group"), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# dredge_res_residency_lmm_delta <- dredge_res_residency_lmm[dredge_res_residency_lmm$delta<2,]
# 
# write.csv(as.data.frame(dredge_res_residency_lmm_delta), file = "dredge_results_lmm_residency.csv")

best_lmm_residency <- lmer(residency ~ group +log.density + log.dens.self + sex + voyage_event + (1|host), data = df_clean, REML=FALSE) #3941.107

summary(best_lmm_residency)
```

Le facteur mixte hôte n'est pas significatif pour le meilleur modèle sélectionné. Ce modèle est le même qu'avant.

De manière robuste on peut dire que le temps de résidence est expliqué significativement par le phylogroupe, les log-densités. Les déterminants hôtes ne sont pas très significatifs mais le sexe et le fait d'avoir fait un voyage sortent.

#### Temps de résidence log-scaled

On va maintenant expliquer les temps de résidence log-scaled.

##### Régression linéaire multiple sans effet mixte

###### Sélection par stepAIC

```{r logresidency_all_lm}
#On utilise qu'une partie du df :
lm_df_logresidency <- longitudinal_strain_host

lm_df_logresidency <- na.omit(lm_df_logresidency)

lm_df_logresidency$date_min <- NULL
lm_df_logresidency$date_max <- NULL
lm_df_logresidency$dates_samples <- NULL
lm_df_logresidency$resident_status <- NULL
lm_df_logresidency$mlva <- NULL
lm_df_logresidency$residency_scaled_groups <- NULL
lm_df_logresidency$residency <- NULL
lm_df_logresidency$host <- NULL
lm_df_logresidency$id.clone <- NULL
lm_df_logresidency$time_since_start <- NULL
lm_df_logresidency$time_max <- NULL

lm_df_logresidency$density <- NULL
lm_df_logresidency$dens.self <- NULL

#Soit on utilise les catégories soit les variables plus précises:
lm_df_logresidency$code_postal <- NULL
#lm_df_logresidency$ville_group <- NULL

lm_df_logresidency$age <- NULL
#lm_df_logresidency$age_group <- NULL

lm_df_logresidency$score_epices <- NULL
#lm_df_logresidency$precarity_group <- NULL

lm_df_logresidency$sport_frequence <- NULL
#lm_df_logresidency$sport_group <- NULL

#lm_df_logresidency$nombre_foyer <- NULL
lm_df_logresidency$foyer_group <- NULL

lm_df_logresidency$taille_cm <- scale(lm_df_logresidency$taille_cm)
lm_df_logresidency$poids <- scale(lm_df_logresidency$poids)

residency_lm_2 <- lm(residency_scaled_log_groups ~ ., data = lm_df_logresidency)

summary(residency_lm_2)

#stepAIC(residency_lm_2, direction = "both")

best_lm_logresidency <- lm(formula = residency_scaled_log_groups ~ log.density + log.dens.self + sex + voyage_event, data = lm_df_logresidency)

summary(best_lm_logresidency)
Anova(best_lm_logresidency)
```

Comme dans le précédent modèle c'est le sexe et les voyages qui sortent en plus des déterminants bactériens. Le phylogroupe ne sort pas car on l'a déjà pris en compte dans la standardisation.

Nous allons effectuer un autre type de sélection pour confirmer la robustesse de la première.

###### Sélection exhaustive par dredge

```{r logresidency_all_lm_exaustive}
#Selection du meilleur modèle :
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_logresidency_lm <- dredge(residency_lm_2, m.lim = c(0, 8), fixed = c("log.density","log.dens.self"), rank = "AIC", cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# Meilleur modèle
best_lm_logresidency <- lm(formula = residency_scaled_log_groups ~ log.density + log.dens.self + sex + voyage_event, data = lm_df_logresidency) #240.8177

summary(best_lm_logresidency)
Anova(best_lm_logresidency)
```

Cette méthode sélectionne le même modèle que la sélection locale. Le sexe et les voyages sortent comme variables pour expliquer les temps de résidence log-scaled.

##### Régression linéaire multiple avec effet mixte

On va incorporer un effet mixte et faire une sélection de modèle avec cet effet mixte toujours présent (ainsi que les trois facteurs bactériens sortant dans le meilleur lm). Ceci va permettre de rendre encore plus robustes nos résultats et de voir s'il y a changement.

```{r logresidency_lmm}
df_clean <- na.omit(longitudinal_strain_host)

#Selection du meilleur lmm
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_logresidency_lmm <- dredge(lmer(residency_scaled_log_groups ~ group + log.density + log.dens.self + regime + precarity_group + sex + age_group + taille_cm + poids + voie_accouchement + allaitement + nombre_foyer + nombre_enfants + sport_group + ville_group + prise_antibiotique + voyage_event + (1 | host), data = df_clean, REML=FALSE)
#    , m.lim = c(0, 8), fixed = c("log.density","log.dens.self"), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

best_lmm_logresidency <- lmer(residency_scaled_log_groups ~ log.density + log.dens.self + sex + voyage_event + (1|host), data = df_clean, REML=FALSE) #242.8158

summary(best_lmm_logresidency)
```

L'effet mixte ne change rien à la sélection. Il est toutefois pas tout à fait nul (pour une fois).

### Pour les souches résidentes 

On sélectionne uniquement les souches résidentes pour se concentrer sur la variabilité des temps de résidence non égaux à 14 (avant la distribution était biaisé vers 14 jours). On sélectionne uniquement les résidentes en prenant toutes les souches dont les temps de résidence sont plus grands que 14.

#### Temps de résidence

On va faire plusieurs méthodes de sélection de modèle et voir la congruence entre méthodes pour sélectionner les variables qui expliquent le mieux la résidence de nos souches.

##### Régression linéaire multiple sans effet mixte

###### Sélection par stepAIC

```{r residency_notall_lm}
#On utilise qu'une partie du df :
lm_df_resident <- longitudinal_strain_host

lm_df_resident <- na.omit(lm_df_resident)

lm_df_resident$date_min <- NULL
lm_df_resident$date_max <- NULL
lm_df_resident$dates_samples <- NULL
lm_df_resident$mlva <- NULL
lm_df_resident$residency_scaled_groups <- NULL
lm_df_resident$residency_scaled_log_groups <- NULL
lm_df_resident$host <- NULL
lm_df_resident$id.clone <- NULL
lm_df_resident$time_since_start <- NULL
lm_df_resident$time_max <- NULL

lm_df_resident$density <- NULL
lm_df_resident$dens.self <- NULL

#Soit on utilise les catégories soit les variables plus précises:
lm_df_resident$code_postal <- NULL
#lm_df_resident$ville_group <- NULL

lm_df_resident$age <- NULL
#lm_df_resident$age_group <- NULL

lm_df_resident$score_epices <- NULL
#lm_df_resident$precarity_group <- NULL

lm_df_resident$sport_frequence <- NULL
#lm_df_resident$sport_group <- NULL

#lm_df_resident$nombre_foyer <- NULL
lm_df_resident$foyer_group <- NULL

lm_df_resident$taille_cm <- scale(lm_df_resident$taille_cm)
lm_df_resident$poids <- scale(lm_df_resident$poids)

lm_df_resident <- lm_df_resident[lm_df_resident$resident_status,]

lm_df_resident$resident_status <- NULL

residency_lm_3 <- lm(residency ~ ., data = lm_df_resident)

summary(residency_lm_3)

#stepAIC(residency_lm_3, direction = "both")

best_lm_resident <- lm(formula = residency ~ regime + sex + allaitement, data = lm_df_resident)

summary(best_lm_resident)
Anova(best_lm_resident)
```

Aucun des facteurs bactériens ne sort. Les facteurs hôtes qui sortent ne sont pas significatifs. La sélection par comparaison de AIC est caduque car il y a trop de variables à expliquer pour pas assez de données.

On va donc faire une sélection avec dredge avec la comparaison via AICc.

###### Sélection exhaustive par dredge

```{r residency_notall_lm_exaustive}
#Selection du meilleur modèle :
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_resident_lm <- dredge(residency_lm_3, rank = "AICc", m.lim = c(0, 5), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# Meilleur modèle
best_lm_residency_resident <- lm(formula = residency ~ nombre_enfants + poids, data = lm_df_resident) #1172.663

summary(best_lm_residency_resident)
Anova(best_lm_residency_resident)
```

Cette sélection mène au choix du nombre d'enfants pour expliquer la résidence des souches résidentes. Ceci pourrait être un effet âge caché. 

##### Régression linéaire multiple avec effet mixte

```{r resident_lmm}
df_clean <- na.omit(longitudinal_strain_host)

df_clean <- df_clean[df_clean$resident_status,]

#Selection du meilleur lmm
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_resident_lmm <- dredge(lmer(residency ~ group + log.density + log.dens.self + regime + precarity_group + sex + age_group + taille_cm + poids + voie_accouchement + allaitement + nombre_foyer + nombre_enfants + sport_group + ville_group + prise_antibiotique + voyage_event + (1 | host), data = df_clean, REML=FALSE)
#   , m.lim = c(0, 5), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# dredge_res_resident_lmm_delta <- dredge_res_resident_lmm[dredge_res_resident_lmm$delta<2,]
# 
# write.csv(as.data.frame(dredge_res_resident_lmm_delta), file = "dredge_results_lmm_resident.csv")

best_lmm_resident <- lm(residency ~ nombre_enfants+ poids, data = df_clean, REML=FALSE) #1174.81

summary(best_lmm_resident)
Anova(best_lmm_resident)
```

L'effet mixte ne change rien à l'AIC.

Quand on considère uniquement les souches résidentes on observe que c'est le nombre d'enfants qui sort comme variable explicative des temps de résidence. 
L'effet de cette variable vient du seuil entre Adultes et Jeunes adultes (sans enfants). C'est donc probablement un effet âge caché.

#### Temps de résidence log-scaled

On sélectionne les résidentes à l'aide de leur temps de résidence avant qu'on scale.

##### Régression multiple sans effet mixte

###### Sélection par stepAIC

```{r logresidency_notall_lm}
#On utilise qu'une partie du df :
lm_df_logresident <- longitudinal_strain_host

lm_df_logresident <- na.omit(lm_df_logresident)

lm_df_logresident$date_min <- NULL
lm_df_logresident$date_max <- NULL
lm_df_logresident$dates_samples <- NULL
lm_df_logresident$mlva <- NULL
lm_df_logresident$residency_scaled_groups <- NULL
lm_df_logresident$residency <- NULL
lm_df_logresident$host <- NULL
lm_df_logresident$id.clone <- NULL
lm_df_logresident$time_since_start <- NULL
lm_df_logresident$time_max <- NULL

lm_df_logresident$density <- NULL
lm_df_logresident$dens.self <- NULL

#Soit on utilise les catégories soit les variables plus précises:
lm_df_logresident$code_postal <- NULL
#lm_df_logresident$ville_group <- NULL

lm_df_logresident$age <- NULL
#lm_df_logresident$age_group <- NULL

lm_df_logresident$score_epices <- NULL
#lm_df_logresident$precarity_group <- NULL

lm_df_logresident$sport_frequence <- NULL
#lm_df_logresident$sport_group <- NULL

#lm_df_logresident$nombre_foyer <- NULL
lm_df_logresident$foyer_group <- NULL

lm_df_logresident$taille_cm <- scale(lm_df_logresident$taille_cm)
lm_df_logresident$poids <- scale(lm_df_logresident$poids)

lm_df_logresident <- lm_df_logresident[lm_df_logresident$resident_status,]

lm_df_logresident$resident_status <- NULL

residency_lm_4<- lm(residency_scaled_log_groups ~ ., data = lm_df_logresident)

summary(residency_lm_4)

#stepAIC(residency_lm_4, direction = "both")

best_lm_logresident <- lm(formula = residency_scaled_log_groups ~ group + log.density + log.dens.self + poids + voie_accouchement + allaitement, data = lm_df_logresident)

summary(best_lm_logresident)
Anova(best_lm_logresident)
```

Les trois déterminants bactériens sont sélectionnés sans être tous significatifs. Le phylogroupe est sélectionné (alors qu'on considère une mesure standardisée pour enlever l'effet phylogroupe, peut être seulement pour le temps pas scalé justement).

Le poids, l'allaitement et la voie d'accouchement sont sélectionnés mais pas significatifs.

Il faut faire une approche par dredge pour voir la cohérence.

###### Sélection exhaustive par dredge

```{r logresidency_notall_lm_exaustive}
#Selection du meilleur modèle :
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_logresident_lm <- dredge(residency_lm_4, rank = "AICc", m.lim = c(0, 7), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# Meilleur modèle
best_lm_logresident <- lm(formula = residency_scaled_log_groups ~ group + ville_group, data = lm_df_logresident)

summary(best_lm_logresident)
Anova(best_lm_logresident)
```

La sélection de modèle n'est pas congruente. Il faudrait un peu creuser mais je pense que il y a peu de réalité biologique derrière la métrique que je veux prédire.

On va voir si les effets mixtes jouent. Il faut réduire la complexité.

##### Régression multiple avec effet mixte

```{r logresident_lmm}
df_clean <- na.omit(longitudinal_strain_host)

df_clean <- df_clean[df_clean$resident_status,]

#Selection du meilleur lmm
# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_res_logresident_lmm <- dredge(lmer(residency_scaled_log_groups ~ group + log.density + log.dens.self + regime + precarity_group + sex + age_group + taille_cm + poids + voie_accouchement + allaitement + nombre_foyer + nombre_enfants + sport_group + ville_group + prise_antibiotique + voyage_event + (1 | host), data = df_clean, REML=FALSE) ,fixed = c("group") , m.lim = c(0, 7), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

best_lmm_resident <- lmer(residency_scaled_log_groups ~ group + ville_group + (1|host), data = df_clean, REML=FALSE) #93.59
```

On sélectionne les deux mêmes variables qu'avant.

## Régression logistique pour le statut de résidence

On va étudier l'effet des déterminants hôtes et bactériens sur la probabilité d'être résident avec une régression logistique binaire (oui/non au statut de résident) qui fait partie de la classe de modèle des GLM.

On va d'abord considérer des modèles sans effet mixtes car ceux ci ne sont pas significatifs dans nos données (voir partie précédente). On va faire une sélection par stepAIC qu'on va ensuite confirmer par une sélection "exhaustive" par dredge. On incorporera ensuite un effet mixte pour mettre au clair son effet.

### Régression logistique sans effet mixte

#### Sélection par stepAIC

```{r glm_resident_nomixed}
glm_df_resident <- longitudinal_strain_host

glm_df_resident <- na.omit(glm_df_resident)

glm_df_resident$mlva <- NULL
glm_df_resident$id.clone <- NULL
glm_df_resident$residency <- NULL
glm_df_resident$residency_scaled_groups <- NULL
glm_df_resident$residency_scaled_log_groups <- NULL
glm_df_resident$host <- NULL
glm_df_resident$date_min <- NULL
glm_df_resident$date_max <- NULL
glm_df_resident$dates_samples <- NULL
glm_df_resident$time_since_start <- NULL
glm_df_resident$time_max <- NULL

glm_df_resident$dens.self <- NULL
glm_df_resident$density <- NULL

glm_df_resident$code_postal <- NULL
glm_df_resident$foyer_group <- NULL
glm_df_resident$sport_group <- NULL
glm_df_resident$pays_de_naissance <- NULL
glm_df_resident$age <- NULL

# On centre et réduit les variables continues qu'on va utiliser
glm_df_resident$log.density <- scale(glm_df_resident$log.density) 
glm_df_resident$log.dens.self<- scale(glm_df_resident$log.dens.self) 

glm_resident <- glm(resident_status~ ., data = glm_df_resident, family = binomial())

summary(glm_resident)

#stepAIC(glm_resident)

best_glm_resident <- glm(formula = resident_status ~ group + log.density + log.dens.self + 
    nombre_foyer + age_group, family = binomial(), data = glm_df_resident)

summary(best_glm_resident)

Anova(best_glm_resident)
```

La sélection rapide par stepAIC fait ressortir les 3 déterminants bactériens et le nombre de personnes dans le foyer ainsi que l'âge comme variables explicative du statut de résidence. Les vieux auraient moins de probabilités d'avoir des souches résidentes. 

La densité globale diminue la probabilité de devenir résidente. Ceci pourrait être expliqué par le fait que si un hôte a une grande densité de E. coli ceci vient du fait qu'il est déjà colonisé par une souche résidente (et même d'autres Enterobactérie) ce qui diminue la probabilité pour une souche de s'installer en tant que résidente.

La densité focale (propre) augmente la probabilité de devenir résidente. Ceci pourrait être expliqué par le fait que les souches résidentes ont de plus grandes densité dans l'intestin car elles sont installées. Ainsi, avoir une plus grande densité propre augmente la probabilité d'être assimilé à une souche qui s'est installé et donc qui réside.

On voit aussi que le phylogroupe influence le statut de résidence. On retrouve donc des phylogroupes avec plus de probabilités que d'autres de donner des souches résidentes et transientes.

#### Sélection exhaustive par dredge

On va faire une sélection plus robuste en considérant tous les modèles de maximum 8 variables explicatives et en forçant le phylogroupe et les densités (car elles sont sorties très significatives).

```{r glm_resident_exaustive}
#Meilleur modèle selectioné par dredge
# options(na.action = "na.fail")
# 
# cl <- makeCluster(detectCores() - 1)
# 
# dredge__res_glm_resident <- dredge(glm_resident, m.lim = c(0, 7), rank = "AIC", fixed = c("group","log.density","log.dens.self"), cluster = cl)
# 
# stopCluster(cl)
# options(na.action = "na.omit")

best_glm_resident <- glm(formula = resident_status ~ group + log.density + log.dens.self + 
    nombre_foyer + age_group + nombre_enfants, family = binomial(), data = glm_df_resident) #AIC:397.166

summary(best_glm_resident)
Anova(best_glm_resident)
```

Même sélection que le stepAIC. Le régime et le sexe sont aussi souvent sélectionnés dans les meilleurs modèles.

### Régression logistique avec effets mixtes

On incorpore maintenant un effet mixte (glmm) et on refait une sélection exhaustive pour voir la robustesse de notre modèle sélectionné, ainsi que l'effet de l'effet mixte hôte.

```{r glmm}
glmm_df_resident <- longitudinal_strain_host

glmm_df_resident <- na.omit(glmm_df_resident)

glmm_df_resident$mlva <- NULL
glmm_df_resident$id.clone <- NULL
glmm_df_resident$residency <- NULL
glmm_df_resident$residency_scaled_groups <- NULL
glmm_df_resident$residency_scaled_log_groups <- NULL
glmm_df_resident$date_min <- NULL
glmm_df_resident$date_max <- NULL
glmm_df_resident$dates_samples <- NULL
glmm_df_resident$time_since_start <- NULL
glmm_df_resident$time_max <- NULL

glmm_df_resident$code_postal <- NULL
glmm_df_resident$foyer_group <- NULL
glmm_df_resident$pays_de_naissance <- NULL
glmm_df_resident$age <- NULL
glmm_df_resident$sport_frequence <- NULL

# On centre et réduit les variables continues qu'on va utiliser
glmm_df_resident$log.density <- scale(glmm_df_resident$log.density) 
glmm_df_resident$log.dens.self<- scale(glmm_df_resident$log.dens.self) 

glmm_df_resident$dens.self <- NULL
glmm_df_resident$density <- NULL

#Meilleur modèle selectioné par :
# options(na.action = "na.fail")
# cl <- makeCluster(detectCores() - 1)
# dredge_res_glmm_resident <- dredge(glmer(resident_status ~ group + log.density + log.dens.self + regime + scale(score_epices) + sex + age_group + taille_cm + poids + voie_accouchement + allaitement + nombre_foyer + nombre_enfants + sport_group + ville_group + prise_antibiotique + voyage_event + (1 | host), family = binomial, data = glmm_df_resident), m.lim = c(0, 6), fixed = c("log.density","log.dens.self", "group"), cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")
# 
# res_glmm_resident_delta <- dredge_res_glmm_resident[dredge_res_glmm_resident$delta<2,]
# 
# write.csv(as.data.frame(res_glmm_resident_delta), file = "dredge_results_glmm_resident.csv")

best_glmm_resident <- glmer(resident_status ~ group + log.density + log.dens.self + age_group + nombre_foyer + (1 | host), family = binomial, data = glmm_df_resident) #AIC : 399.166

summary(best_glmm_resident)
Anova(best_glmm_resident)
```

L'effet mixte ne change rien, les AIC sont les mêmes. On va donc dans la suite enlever cet effet mixte.

### Odds Ratio des déterminants du statut de résidence

Comme on modélise la probabilité d'être résident en fonction des déterminants on peut faire des OR et des forest plot afin de mieux visualiser les déterminants de la résidence. On va utiliser le modèle sans effet mixte.

On peut représenter en forest plot les résultats du modèle de résidence. 

```{r OR}
plot_forest_or <- best_glm_resident %>%
  ggstats::ggcoef_model(exponentiate = TRUE) +
  coord_cartesian(xlim = c(0.01, 100)) 

plot_forest_or
```

L'individu de référence est une souche A.1 portée par un homme, d'âge moyen, avec un nombre de personne dans son foyer moyen, dont la densité propre est moyenne et portée par un hôte avec une densité en Enterobactérie moyenne.

Ce plot nous montre que : 
- Une souche chez un hôte avec une plus grande densité globale, comparée à la même souche chez un hôte avec une densité globale plus basse, a moins de chance (OR < 1) d'être résidente. Ceci représente la difficulté à s'installer chez des hôtes avec beaucoup de densité globale.
- Une souche ayant une densité propre plus grande chez un hôte par rapport à la même souche avec une densité moyenne a plus de chance (OR > 1) d'être résidente. 
- Les souches des gens de plus de 40 ans ont moins de chance d'êtres résidentes comparées aux souches des gens de moins de 40 ans.
- Une souche portée par un hôte dans un foyer avec plus de personnes qu'un hôte portant la même souche a moins de chance d'être résidente.
- Les souches de certains phylogroupes ont plus de chances d'êtres résidentes par rapport au phylogroupe A.1, exemple : A.2, B2.3, D.1 et F.

Comme on a les OR on peut obtenir pour chaque souches la proba d'être résident ou pas. 

```{r proba_predict}
proba_resident <- predict(best_glm_resident, type="response")
new_df <- na.omit(longitudinal_strain_host)
new_df$proba_resident <- proba_resident
```

Maintenant qu'on a les probabilités d'être résidents pour chaque souche on peut les représenter en fonction des déterminants pour voir si les déterminants qu'on a détecter augmente vraiment la probabilité d'être résident.

#### Probabilité d'être résident et phylogroupe

```{r phylogroup_proba_residence}
ggplot(new_df, aes(x = group, y = proba_resident, fill = group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x=group), shape = ".", size = 1) +
    geom_beeswarm(dodge.width = 0.01) +
    scale_fill_brewer(palette = "Set1") +  # Adjust fill color palette
    scale_color_brewer(palette = "Dark2") +  # Use a different palette for color
    theme(legend.position = "top") + 
    ggtitle("Probabilité Resident et Phylogroupe")
```
Ce plot permet vraiment d'identifier tous les phylogroupes résident et transient.

#### Probabilité d'être résident et densité globale

```{r phylogroup_proba_residence}
ggplot(new_df, aes(x = log.density, y = proba_resident)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 
```

#### Probabilité d'être résident et densité focale

```{r phylogroup_proba_residence}
ggplot(new_df, aes(x = log.dens.self, y = proba_resident)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 
```

#### Probabilité d'être résident et âge

```{r phylogroup_proba_residence}
ggplot(new_df, aes(x = age_group, y = proba_resident, fill = age_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x=age_group), shape = ".", size = 1) +
    geom_beeswarm(dodge.width = 0.01) +
    scale_fill_brewer(palette = "Set1") +  # Adjust fill color palette
    scale_color_brewer(palette = "Dark2") +  # Use a different palette for color
    theme(legend.position = "top") + 
    ggtitle("Probabilité Resident et Phylogroupe")
```

```{r phylogroup_proba_residence}
ggplot(new_df, aes(x = nombre_foyer, y = proba_resident, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x=nombre_foyer), shape = ".", size = 1) +
    geom_beeswarm(dodge.width = 0.01) +
    scale_fill_brewer(palette = "Set1") +  # Adjust fill color palette
    scale_color_brewer(palette = "Dark2") +  # Use a different palette for color
    theme(legend.position = "top") + 
    ggtitle("Probabilité Resident et Phylogroupe")
```

Le nombre de personne dans le foyer ne modifie vraiment pas tellement la probabilité d'être résident.

## Visualisation des relations entre le nombre de réobservations et les déterminants hôtes / bactériens

Pour cela on calcule le nombre d'observations et on l'ajoute au df `longitudinal_strain_host`.

 On ajoute à `longitudinal_strain_host` le nombre d'observations de chaque souche. Pour que ce soit plus facile dans R on fait plusieurs hypothèses : 

- Un seul sample correspond à une transiente et on lui attribue l'évènement "0 observation" et ainsi de suite (on décale tout de -1).
- On considère que notre sampling a été parfait ie toutes les 2 semaines exactement pour chaque hôte et on va donc diviser par 14 les temps de résidence pour obtenir les observations.

```{r nbr_event}
longitudinal_strain_host <- longitudinal_strain_host %>%
  mutate(number_event = round(residency/14) -1)
```

### Distribution du nombre d'observation

```{r distribution_nbr_event}
# On représente la distribution des observations de souches
plot_distrib_number_event <- ggplot(longitudinal_strain_host, aes(x = number_event)) + 
  geom_histogram(bin = 30) +
  theme_bw() + 
  xlab("Nombre d'observations en tant que résidente")

plot_distrib_number_event
```

La partie de comptage semble plutôt suivre une loi géométrique que Poisson ou Négative Binomiale. 

### Nombre de réobservations et déterminants bactériens

#### Réobservations et phylogroupe

```{r observation_phylogroup_boxplot}
p1 <- ggplot(longitudinal_strain_host, aes(x = group, y = number_event, fill = as.factor(group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Reobservation et Phylogroupe")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = group, y = number_event, fill = as.factor(group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Reobservation et Phylogroupe pour Résident")

grid.arrange(p1, p2, ncol=1)
```

#### Réobservations et densité globale

##### Pas par phylogroupe

```{r observation_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = log.density)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et densité focale

##### Pas par phylogroupe

```{r observation_self_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_self_density_correlation_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = log.dens.self)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

On observe les mêmes dynamiques que pour les temps de résidence.

### Nombre de réobservatons et déterminants hôtes

#### Réobservations et Âge

##### Pas par phylogroupe 

```{r observation_age, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_age, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = age)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Classification en âge

Pour augmenter la puissance de la variable âge on l'a catégorisé.

```{r age_group_observation, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = age_group, y = number_event, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Age")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = age_group, y = number_event, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Age pour Résident")

grid.arrange(p1, p2, ncol=2)
```

L'âge ne semble pas affecter le nombre d'observations.

#### Réobservations et Score EPICES

##### Pas par phylogroupe

```{r observation_epices, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_epices_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Régime Alimentaire

##### Tout le régime

```{r observation_diet, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = regime, y = number_event, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Diet")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = regime, y = number_event, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Diet pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Sexe

```{r observation_sex, fig.height=20, fig.width=20}
longitudinal_strain_host$sex = as.factor(longitudinal_strain_host$sex)

p1 <- ggplot(longitudinal_strain_host, aes(x = sex, y = number_event, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sexe")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sex, y = number_event, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sexe pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Poids

##### Pas par phylogroupe

```{r observation_weigth, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_weigth_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Allaitement

```{r observation_allaitement, fig.height=20, fig.width=20}
longitudinal_strain_host$allaitement = as.factor(longitudinal_strain_host$allaitement)

p1 <- ggplot(longitudinal_strain_host, aes(x = allaitement, y = number_event, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Allaitement")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = allaitement, y = number_event, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Allaitement pour Résident")

grid.arrange(p1, p2, ncol=2)
```


#### Réobservations et Accouchement

```{r observation_accouchement, fig.height=20, fig.width=20}
longitudinal_strain_host$voie_accouchement = as.factor(longitudinal_strain_host$voie_accouchement)

p1 <- ggplot(longitudinal_strain_host, aes(x = voie_accouchement, y = number_event, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Voie Accouchement")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voie_accouchement, y = number_event, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Voie Accouchement pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Sport

```{r observation_sportfreq, fig.height=20, fig.width=20}
longitudinal_strain_host$sport_frequence = as.factor(longitudinal_strain_host$sport_frequence)

p1 <- ggplot(longitudinal_strain_host, aes(x = sport_frequence, y = number_event, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sport")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_frequence, y = number_event, fill = sport_frequence)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_frequence), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sport pour Résident")

grid.arrange(p1, p2, ncol=2)
```


Voyons si catégoriser la fréquence en Fréquent / Non Fréquent change quelque chose.

```{r observation_sportgroup, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = sport_group, y = number_event, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sport")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = sport_group, y = number_event, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Sport pour Résident")

grid.arrange(p1, p2, ncol=2)
```


#### Réobservations et Nombre Foyer

```{r observation_foyer, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = nombre_foyer, y = number_event, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Foyer")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_foyer, y = number_event, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Foyer pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Taille

##### Pas par phylogroupe

```{r observation_height, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```

##### Par phylogroupe

```{r observation_height_phylo, fig.height=40, fig.width=40}
p1 <- ggplot(longitudinal_strain_host, aes(x = number_event, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = number_event, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  facet_wrap(~group, scales = "free") + 
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

grid.arrange(p1, p2, ncol=2)
```


#### Réobservations et Nombre d'enfants

```{r observation_enfants, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = nombre_enfants, y = number_event, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Enfants")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = nombre_enfants, y = number_event, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Enfants pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Prise d'antibiotique

```{r observation_antibio, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = prise_antibiotique , y = number_event, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Antibio")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = prise_antibiotique, y = number_event, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Antibio pour Résident")

grid.arrange(p1, p2, ncol=2)
```

#### Réobservations et Voyage

```{r observation_voyage, fig.height=20, fig.width=20}
p1 <- ggplot(longitudinal_strain_host, aes(x = voyage_event , y = number_event, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Voyage")

p2 <- ggplot(longitudinal_strain_host[longitudinal_strain_host$resident_status,], aes(x = voyage_event, y = number_event, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    geom_beeswarm(dodge.width = 0.01) +
    theme(legend.position = "none") + 
    ggtitle("Réobservations et Voyage pour Résident")

grid.arrange(p1, p2, ncol=2)
```

## ZI model pour le nombre de réobservations d'une souche 

On utilise un zero-inflated (ZI) model. Les régressions ZI avec géométrique étant assez peu développée, on fait du ZI négative binomiale (car celle ci prend en compte la géometrique pour un succès r = 1). La sélection de modèle était assez complexe... 

Nous avons fait la sélection d'abord en trouvant les meilleurs modèles pour la partie inflation puis pour la partie count.

On n'a pas mis d'effets mixtes dans le ZI car ceci augmentait grandement la complexité de la sélection de modèle.

On utilise le AICc car comme il converge vers le AIC c'est plus robuste si jamais zeroinfl() considère qu'une petite partie des données pour la partie count.

Selection par comparaison des AICc en commençant par la partie count puis inflation. On l'a lancé une fois puis on va utiliser les résultats pour fixer à tour de rôle les parties et resélectionner (on va refixer inflation mais cette fois avec le résultat du premier script et pareil pour count ensuite). Ensuite on va faire la même chose en inversant tout et en partant de inflation puis count (plus réaliste sur le pdv biologie).

Première itération :

```{r selection_zimod_fixed_othersense}
# Sélection manuelle ZI avec zeroinfl (sans effets aléatoires)

#1. Préparer les données
df <- longitudinal_strain_host %>%
  na.omit() %>%
  mutate(
    host           = as.factor(host),
    log.dens.self  = scale(log.dens.self),
    log.density    = scale(log.density),
    age            = scale(age),
    poids          = scale(poids),
    taille_cm      = scale(taille_cm),
    nombre_foyer   = scale(nombre_foyer)
  ) %>%
  dplyr::select(-c(
    mlva, id.clone, residency, residency_scaled_groups,
    residency_scaled_log_groups, resident_status,
    date_min, date_max, dates_samples,
    time_since_start, time_max, age, precarity_group, foyer_group,
    density, dens.self, code_postal, pays_de_naissance, sport_group, host
  ))

df$allaitement <- as.factor(df$allaitement)
df$voie_accouchement <- as.factor(df$voie_accouchement)

# Recode "group" pour éviter les niveaux rares
counts <- table(df$group, df$sex)
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
df$group <- as.character(df$group)
df$group[df$group %in% rare_levels] <- "other"
df$group <- factor(df$group)

# # #SELECTION : 
# 
# # 2. Définir les variables
# resp    <- "number_event"
# forced  <- c("log.density", "log.dens.self", "group")
# all_terms <- attr(terms(as.formula(paste0(resp, " ~ .")), data = df), "term.labels")
# #cand_inflation    <- setdiff(all_terms, forced)
# cand_inflation <- all_terms
# cand_count <- all_terms
# 
# # 3. Générer combinaisons 1 à 5 pour inflation
# combo_list_inflation <- unlist(
#   lapply(1:6, function(k) combn(cand_inflation, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Générer combinaisons 1 à 5 pour count
# combo_list_count <- unlist(
#   lapply(1:6, function(k) combn(cand_count, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Initialiser le cluster
# ncores <- 6
# cl <- makeCluster(ncores)
# 
# # On charge les package sur chaque coeur
# clusterEvalQ(cl, {
#   library(pscl)
#   library(MuMIn)
# })
# 
# clusterExport(cl, c("df", "resp", "forced", "combo_list_count"), envir = environment())
# 
# # 5. Selection COUNT (partie gauche du modèle ZI)
# res_count_list <- parLapply(cl, combo_list_count, function(vars) {
#   combo_name <- paste(vars, collapse = " + ")
#   count_formula <- paste(vars, collapse = " + ")
#   tryCatch({
#     m <- zeroinfl(
#       formula = as.formula(paste0(resp, " ~", count_formula ,"| 1")),
#       data = df, dist = "negbin"
#     )
#     list(combo = combo_name, AICc = AICc(m))
#   }, error = function(e) list(combo = combo_name, AICc = NA))
# })
# 
# # Modèle avec variable forcée seule pour count
# base_count_aic <- tryCatch({
#   m0 <- zeroinfl(
#     formula = as.formula(paste0(resp, " ~  1 | 1")),
#     data = df, dist = "negbin"
#   )
#   AICc(m0)
# }, error = function(e) NA)
# 
# res_count <- bind_rows(
#   tibble(combo = "(none)", AICc = base_count_aic),
#   bind_rows(lapply(res_count_list, as_tibble))
# ) %>%
#   #filter(!is.na(AICc)) %>%
#   arrange(AICc) %>%
#   mutate(delta = AICc - min(AICc),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("\n=== Sélection Count ===\n")
# print(res_count)
# 
# # 6. Meilleure formule INFLATION
# best_count_combo <- res_count$combo[1]
# vars_count <- if (best_count_combo == "(none)") "1" else strsplit(best_count_combo, " \\+ ")[[1]]
# final_count_formula <- paste(vars_count, collapse = " + ")
# #final_count_formula <- "group + log.density + log.dens.self"
# 
# # 7. Sélection ZI (partie de droite du modèle ZI)
# ## Avant parLapply, on exporte aussi final_count_formula
# clusterExport(cl, c("df", "resp", "forced", "combo_list_inflation", "final_count_formula"), envir = environment())
# 
# # On fixe certaines variable dont on est sur qu'elles vont sortir
# res_zi_list <- parLapply(cl, combo_list_inflation, function(vars) {
#   zi_part <-  paste(vars, collapse = " + ")
#   # On assemble l'ensemble en une seule formule
#   f <- as.formula(
#     paste0(resp, " ~ ", final_count_formula, " | ", zi_part)
#   )
#   tryCatch({
#     m <- zeroinfl(f, data = df, dist = "negbin")
#     list(combo = zi_part, AICc = AICc(m))
#   }, error = function(e) {
#     message("Erreur pour combo ", zi_part, " : ", e$message)
#     list(combo = zi_part, AICc = NA)
#   })
# })
# 
# # Ajouter modèle de base : number_event ~ count_best | 1
# base_formula <- as.formula(
#   paste0(resp, " ~",  final_count_formula ,"| 1")
# )
# 
# base_aic <- tryCatch({
#   m0 <- zeroinfl(base_formula , data = df, dist = "negbin")
#   AICc(m0)
# }, error = function(e) NA)
# 
# res_zi <- bind_rows(
#   tibble(combo = "(none)", AICc = base_aic),
#   bind_rows(lapply(res_zi_list, as_tibble))
# ) %>%
#   #filter(!is.na(AICc)) %>%
#   arrange(AICc) %>%
#   mutate(delta = AICc - min(AICc),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("=== Sélection ZI ===\n")
# print(res_zi)
# 
# # 7. Meilleure formule ZI Si fixation de forced alors "1" devient character(0)
# best_zi_combo <- res_zi$combo[1]
# vars_zi <- if (best_zi_combo == "(none)") "1" else strsplit(best_zi_combo, " \\+ ")[[1]]
# final_zi_formula <- paste(vars_zi, collapse = " + ")
# 
# # 8. Ajustement modèle final
# final_formula <- as.formula(
#   paste0(resp, " ~ ", if (final_count_formula == "") "1" else final_count_formula, " | ", final_zi_formula)
# )
# final_model_1 <- zeroinfl(final_formula , data = df, dist = "negbin")
# 
# cat("\n=== Résumé du modèle final ===\n")
# summary(final_model_1)
# 
# # 9. Stopper le cluster
# stopCluster(cl)

#modele_selected_first_iteration <- zeroinfl(number_event~ group + log.density + log.dens.self | group + log.density + log.dens.self + nombre_foyer, data = df, dist="negbin")
```

Lors de la première itération on trouve (voir screen) que pour count c'est group + log.density + log.dens.self (avec 1 pour la partie inflation) et pour inflation c'est group + log.density + log.dens.self + nombre_foyer (avec group + log.density + log.dens.self pour la partie count fixée).

Deuxième itération : on repart du meilleur modèle inflation qu'on fixe et on reselectionne count. Puis pareil pour inflation avec le meilleur count. On voit si cela change les sélections et on recommence pour une troisième si jamais.

```{r deuxième_itération}
#SELECTION :

# 2. Définir les variables
# resp    <- "number_event"
# all_terms <- attr(terms(as.formula(paste0(resp, " ~ .")), data = df), "term.labels")
# 
# cand_inflation <- all_terms
# cand_count <- all_terms
# 
# # 3. Générer combinaisons 1 à 5 pour inflation
# combo_list_inflation <- unlist(
#   lapply(1:6, function(k) combn(cand_inflation, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Générer combinaisons 1 à 5 pour count
# combo_list_count <- unlist(
#   lapply(1:6, function(k) combn(cand_count, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Initialiser le cluster
# ncores <- 6
# cl <- makeCluster(ncores)
# 
# # On charge les package sur chaque coeur
# clusterEvalQ(cl, {
#   library(pscl)
#   library(MuMIn)
# })
# 
# clusterExport(cl, c("df", "resp", "combo_list_count"), envir = environment())
# # 5. Selection COUNT (partie gauche du modèle ZI)
# res_count_list <- parLapply(cl, combo_list_count, function(vars) {
#   combo_name <- paste(vars, collapse = " + ")
#   count_formula <- paste(vars, collapse = " + ")
#   tryCatch({
#     m <- zeroinfl(
#       formula = as.formula(paste0(resp, " ~", count_formula ,"| group + log.density + log.dens.self + nombre_foyer")),
#       data = df, dist = "negbin"
#     )
#     list(combo = combo_name, AICc = AICc(m))
#   }, error = function(e) list(combo = combo_name, AICc = NA))
# })
# 
# # Modèle avec variable forcée seule pour count
# base_count_aic <- tryCatch({
#   m0 <- zeroinfl(
#     formula = as.formula(paste0(resp, " ~  1 | group + log.density + log.dens.self + nombre_foyer")),
#     data = df, dist = "negbin"
#   )
#   AICc(m0)
# }, error = function(e) NA)
# 
# res_count <- bind_rows(
#   tibble(combo = "(none)", AICc = base_count_aic),
#   bind_rows(lapply(res_count_list, as_tibble))
# ) %>%
#   #filter(!is.na(AICc)) %>%
#   arrange(AICc) %>%
#   mutate(delta = AICc - min(AICc),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("\n=== Sélection Count ===\n")
# print(res_count)
# 
# # 6. Meilleure formule INFLATION
# best_count_combo <- res_count$combo[1]
# vars_count <- if (best_count_combo == "(none)") "1" else strsplit(best_count_combo, " \\+ ")[[1]]
# final_count_formula <- paste(vars_count, collapse = " + ")
# 
# #7. Sélection ZI (partie de droite du modèle ZI)
# # Avant parLapply, on exporte aussi final_count_formula
# clusterExport(cl, c("df", "resp", "combo_list_inflation", "final_count_formula"), envir = environment())
# 
# # On fixe certaines variable dont on est sur qu'elles vont sortir
# res_zi_list <- parLapply(cl, combo_list_inflation, function(vars) {
#   zi_part <-  paste(vars, collapse = " + ")
#   # On assemble l'ensemble en une seule formule
#   f <- as.formula(
#     paste0(resp, " ~ ", final_count_formula, " | ", zi_part)
#   )
#   tryCatch({
#     m <- zeroinfl(f, data = df, dist = "negbin")
#     list(combo = zi_part, AICc = AICc(m))
#   }, error = function(e) {
#     message("Erreur pour combo ", zi_part, " : ", e$message)
#     list(combo = zi_part, AICc = NA)
#   })
# })
# 
# # Ajouter modèle de base : number_event ~ count_best | 1
# base_formula <- as.formula(
#   paste0(resp, " ~",  final_count_formula ,"| 1")
# )
# 
# base_aic <- tryCatch({
#   m0 <- zeroinfl(base_formula , data = df, dist = "negbin")
#   AICc(m0)
# }, error = function(e) NA)
# 
# res_zi <- bind_rows(
#   tibble(combo = "(none)", AICc = base_aic),
#   bind_rows(lapply(res_zi_list, as_tibble))
# ) %>%
#   #filter(!is.na(AICc)) %>%
#   arrange(AICc) %>%
#   mutate(delta = AICc - min(AICc),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("=== Sélection ZI ===\n")
# print(res_zi)
# 
# # 7. Meilleure formule ZI Si fixation de forced alors "1" devient character(0)
# best_zi_combo <- res_zi$combo[1]
# vars_zi <- if (best_zi_combo == "(none)") "1" else strsplit(best_zi_combo, " \\+ ")[[1]]
# final_zi_formula <- paste(vars_zi, collapse = " + ")
# 
# # 8. Ajustement modèle final
#  final_formula <- as.formula(
#    paste0(resp, " ~ ", if (final_count_formula == "") "1" else final_count_formula, " | ", final_zi_formula)
#  )
# final_model <- zeroinfl(final_formula , data = df, dist = "negbin")
# 
# cat("\n=== Résumé du modèle final ===\n")
# summary(final_model)
# 
# # 9. Stopper le cluster
# stopCluster(cl)
#  
# res_count_delta <- res_count[res_count$delta<2,]
# write.csv(as.data.frame(res_count_delta), file = "dredge_results_count.csv")
# 
# res_zi_delta <- res_zi[res_zi$delta<2,]
# write.csv(as.data.frame(res_zi_delta), file = "dredge_results_zi.csv")

modele_selected_finaliteration <- zeroinfl(number_event ~ 1 | group + log.density + log.dens.self + nombre_foyer, data=df, dist = "negbin")

summary(modele_selected_finaliteration)
```

On trouve au final qu'avec l'inflation qui prend en compte les 4 facteurs on a plus aucun facteur qui baisse l'AICc du modèle. En repartant sur ce modèle pour count on stagne pour la partie inflation donc on a atteint le meilleur modèle.

Le modèle sélectionne le phylogroupe, les deux logs densités et le nombre de personnes dans le foyer pour la partie inflation et aucune variable pour la partie count.

Aucun de nos facteurs ne semblent avoir une influence significative sur la partie count. Ceci est cohérent avec les résultats sur les modèles linéaires avec seulement les souches résidentes. On a un fort signal que le temps de résidence d'une souche dans l'intestin après sa mise en place en temps que résidente (+ de 14 jours) est indépendant des facteurs hôtes et bactériens considérés dans notre étude. Ceci est assez étonnant et intéressant.

On observe en revanche une augmentation (par rapport à la référence) des probabilités d'être transient chez des personnes avec un nombre plus élevé de personnes dans leur foyer que la moyenne et une densité dans le microbiote plus importante.

Ces résultats sont aussi cohérent avec les facteurs qui sélectionne le fait d'être résident décelé tout à l'heure dans la régression logistique. Cette fois ci l'âge ne sort pas directement (malgré sa présence dans la sélection de modèle) mais le nombre de personnes dans le foyer est certainement corrélé (voir corrélation metadata.rmd)

## Conclusion sur les déterminants de la résidence

Plusieurs effets ressortent que ce soit des déterminants bactériens ou hôtes.

Les logs densités n'ont pas vraiment pour effet d'augmenter les temps de résidence à proprement dit. Les logs densités ont plutôt pour effet de pousser ou non les souches à devenir résidente. 

Si la souche a une densité focale forte c'est qu'elle s'est établie et donc qu'elle peut devenir résidente (ceci augmente indirectement son temps de résidence).

Si la souche est dans un intestin avec forte densité alors elle va avoir du mal à s'établir car il y a déjà une souche résidente, ou alors la souche est la résidente.

Les phylogroupes ont clairement des effets sur le statut résidente ou transiente. Certains phylogroupes ont plus de chances de donner une souche résidente ou transiente. Par contre ce facteur ne modifie pas vraiment le temps dans l'intestin des souches résidentes.

Pour les facteurs hôtes, certains poussent les souches à devenir transiente ou résidente et d'autres poussent les souches à rester plus longtemps dans l'intestin. Globalement les facteurs hôtes modifie la propension d'une souche à être résidente ou transiente. Mais certains semblent aussi influencer la longueur.

Ressortent souvent : 

- Le nombre d'enfants, le nombre de personnes dans le foyer et l'âge sortent comme des variables très corrélées et possèdent le même effet de réduction du temps de portage et d'augmentation de la probabilité de porter des souches transientes (pour un âge plus élevé).
- Le sexe sort comme une variable augmentant les temps de résidence pour les femmes.
- Le fait d'avoir fait un voyage sort aussi.
- Le régime est aussi une variable qui sort souvent dans les modèles influençant la résidence.

# Diversité intrahôte et déterminants hôtes

On crée un df avec les facteurs hôtes et la diversité dans `df_global_diversity`

```{r global_diversity_biased}
# On prépare un dataframe utile pour la richesse spécifique des souches
df_global_diversity <- longitudinal %>%
  group_by(host) %>%
  distinct(id.clone, .keep_all = TRUE) %>%
  mutate(diversity = n()) %>%
  dplyr::select(host, diversity) %>%
  distinct(host, .keep_all = TRUE) %>%
  ungroup()

# 1. Calculer la diversité de chaque hôte
df_diversity <- longitudinal_strain_host %>%
  group_by(host) %>%
  distinct(id.clone, .keep_all = TRUE) %>%
  summarise(diversity = n())

# 2. Identifier les hôtes ayant porté B2.3 plus de 14 jours
b23_status <- longitudinal_strain_host %>%
  filter(group == "B2.3") %>%
  group_by(host) %>%
  summarise(b23_presence = any(residency > 14))

# 3. Joindre avec la diversité pour avoir tous les hôtes
df_global_diversity_2 <- df_diversity %>%
  left_join(b23_status, by = "host") %>%
  mutate(b23_presence = ifelse(is.na(b23_presence), FALSE, b23_presence))

# # Ajout de la densité moyenne des hôtes
# df_global_diversity <- longitudinal %>%
#   group_by(host) %>%
#   distinct(id.sample, .keep_all = TRUE) %>%
#   mutate(mean.log.density = mean(log.density, na.rm = TRUE)) %>%
#    dplyr::select(host, mean.log.density) %>%
#   left_join(df_global_diversity) %>%
#   distinct(host, .keep_all = TRUE) %>%
#   ungroup()
# df_global_diversity[is.nan(df_global_diversity$mean.log.density), "mean.log.density"] <- NA

df_global_diversity <- metadata %>%
  dplyr::select(-c(11:31, 33:42)) %>%
  rename(host = record_id) %>%
  mutate(host = as.factor(host)) %>%
  left_join(df_global_diversity) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence, age_group, precarity_group, foyer_group, ville_group, sport_group), as.factor)) 
  
df_global_diversity <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  ) %>%
  mutate(
    groupe_event = case_when(
      prise_antibiotique == FALSE & voyage_event == FALSE ~ "Aucun",
      prise_antibiotique == TRUE & voyage_event == FALSE ~ "Antibio seul",
      prise_antibiotique == FALSE & voyage_event == TRUE ~ "Voyage seul",
      prise_antibiotique == TRUE & voyage_event == TRUE ~ "Antibio + Voyage"
    )
  ) %>% 
  left_join(df_global_diversity) %>%
  distinct()

df_global_diversity <- df_global_diversity %>%
  mutate(groupe_event = as.factor(groupe_event),
         regime = as.numeric(regime)) %>%
  dplyr::select(-code_postal, -pays_de_naissance, -sport_frequence, -precarity_group, -foyer_group, -age, -groupe_event) %>%
  mutate(taille_cm = scale(taille_cm),
         poids = scale(poids)) %>%
  na.omit()
```

## Visualisation des relations entre la diversité et les déterminants hôtes

### Diversité et Âge

Pour augmenter la puissance de la variable âge on l'a catégorisé.

```{r age_group_diversity, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = age_group, y = diversity, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Age")

p1
```

Il semble y avoir moins de diversité chez les personnes plus âgées. Ca sera probablement une variable intéréssante.

### Diversité et Score EPICES

```{r diversity_epices, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = diversity, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Aucune corrélation entre précarité et diversité.

### Diversité et Régime Alimentaire

```{r diversity_diet, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = regime, y = diversity, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Diet")

p1
```

Le régime semble un peu changer la diversité mais pas de manière drastique.

### Diversité et Sexe

```{r diversity_sex, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = sex, y = diversity, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Sexe")

p1
```

Les femmes semblent avoir un peu moins de diversité que les hommes mais pas de manière incroyable.

### Diversité et Poids

```{r diversity_weigth, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = diversity, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Il semble y avoir une corrélation positive entre le poids et la diversité mais celle-ci est peut être drivée par l'outlier avec un haut poids et une grande diversité.

### Diversité et Allaitement

```{r diversity_allaitement, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = allaitement, y = diversity, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    geom_beeswarm() + 
    theme(legend.position = "none") + 
    ggtitle("Diversité et Allaitement")

p1
```

L'allaitement semble influencer la diversité mais de manière assez faible.

### Diversité et Accouchement

```{r diversity_accouchement, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = voie_accouchement, y = diversity, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    geom_beeswarm() + 
    theme(legend.position = "none") + 
    ggtitle("Diversité et Voie Accouchement")

p1
```

La voie d'accouchement semble aussi un peu influencer la diversité.

### Diversité et Sport

Voyons si catégoriser la fréquence en Fréquent / Non Fréquent change quelque chose.

```{r diversity_sportgroup, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = sport_group, y = diversity, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Sport")

p1
```

Ce qui font moins de sport semblent avoir moins de diversité.

### Diversité et Nombre Foyer

```{r diversity_foyer, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = nombre_foyer, y = diversity, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Foyer")

p1
```

Le nombre de personnes dans le foyer ne semblent pas influencer de facon logique.

### Diversité et Taille

```{r diversity_height, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = diversity, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Corrélation positive mais pas significative.

### Diversité et Nombre d'enfants

```{r diversity_enfants, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = nombre_enfants, y = diversity, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Enfants")

p1
```

Les gens qui ont des enfants (ie les adultes, ie les gens de plus de 40 ans) ont moins de diversité.

### Diversité et Prise d'antibiotique

```{r diversity_antibio, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = prise_antibiotique , y = diversity, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Antibio")

p1
```

La prise d'antibiotique ne semble pas beaucoup influencer la diversité.

### Diversité et Voyage

```{r diversity_voyage, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_diversity, aes(x = voyage_event , y = diversity, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Diversité et Voyage")

p1
```

Ce qui ont fait un voyage n'ont pas forcément plus de diversité comme ce qu'on pourrait attendre.

### Diversité et Densité Globale

```{r diversity_global_density}
# p1 <- ggplot(df_global_diversity, aes(x = diversity, y = mean.log.density)) + 
#   geom_point() + 
#   geom_smooth(method="lm", se=F) +
#   stat_poly_line() +
#   stat_poly_eq(use_label(c("adj.R2", "p"))) 
# 
# p1
```

Pas de corrélation, on ne va pas l'ajouter a posteriori dans les analyses.

## Modèles linéaires pour la diverité des souches

Maintenant qu'on a créé le jeu de données on va utiliser des modèles linéaires pour expliquer la diversité.

On va débiaiser la mesure de diversité car celle ci dépend fortement du nombre de samples que les hôtes ont subi puisqu'il s'agit d'une diversité globale pendant la cohorte.

On va rajouter des variables qui vont tenir compte du sampling inégal : 

- Temps de la cohorte
- Nombre de samples
- Durée moyenne entre les samples

Au final on utilise que le nombre de samples car c'est celui-ci qui prend le mieux en compte le biais attribué au sampling pour la diversité.

```{r global_diversity_unbiased_lm_1_}
#On récupère le nombre de jours de cohorte
time_cohort_df <- longitudinal_strain %>%
  group_by(host) %>%
  mutate(cohort_time = max(time_max)) %>%
  dplyr::select(host, cohort_time) %>% 
  distinct()

sample_cohort_df <- longitudinal %>%
  group_by(host) %>%
  mutate(cohort_sample = n_distinct(date)) %>%
  dplyr::select(host, cohort_sample) %>% 
  distinct()

duree_sample_cohort_df <- longitudinal %>%
  # On regroupe par hôte
  group_by(host) %>%
  # On extrait les dates uniques pour chaque hôte
  distinct(date, .keep_all = TRUE) %>%
  # On trie les dates pour être sûr que le calcul des différences se fasse correctement
  arrange(date) %>%
  # On calcule la différence entre chaque date consécutive (en jours ici, vous pouvez adapter l'unité)
  mutate(diff_jours = as.numeric(difftime(date, lag(date), units = "days"))) %>%
  # On fait la moyenne sur les différences (en ignorant le NA qui apparaît pour la première date)
  summarise(temps_moyen_samples = mean(diff_jours, na.rm = TRUE)) %>%
  ungroup()

# On garde que le nombre de samples
df_global_diversity_unbiased_lm <- df_global_diversity %>%
#  left_join(time_cohort_df) %>%
  left_join(sample_cohort_df) %>%
#  left_join(duree_sample_cohort_df) %>%
  dplyr::select(-host)
```

On va sélectionner le meilleur modèle par comparaison de l'AICc car on a peu de données et beaucoup de variables explicatives.

### Sélection par dredge sur l'AICc

```{r diversity_lm_exaustive}
mod_full <- lm(formula = diversity ~ ., data = df_global_diversity_unbiased_lm)

# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_diversity_unbiased <- dredge(mod_full, m.lim = c(0, 6),fixed = c("cohort_sample") ,rank = "AICc", cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# dredge_diversity_unbiased_delta <- dredge_diversity_unbiased[dredge_diversity_unbiased$delta<2,]
# 
# write.csv(as.data.frame(dredge_diversity_unbiased_delta), file = "dredge_results_diversity.csv")

best_lm_diversity <- lm(diversity ~ allaitement + voie_accouchement + nombre_enfants + poids + cohort_sample, data = df_global_diversity_unbiased_lm)

summary(best_lm_diversity)
Anova(best_lm_diversity)
```

Ainsi, en considérant la richesse spécifique débiaisé par ajout de variable on a que l'allaitement et l'accouchement sortent comme des variables expliquant un peu la diversité, l'âge (via le nombre d'enfants) et le poids sortent aussi.

Le sens des coefficients est : 

- Les personnes non allaitées ont plus de diversité (significatif).
- Les personnes nées par césarienne ont moins de diversité (significatif).
- Les personnes grosses ont plus de diversité.
- Les personnes ayant des enfants (et donc vieux) ont moins de diversité.

## Modèles linéaires pour la diverité des phylogroupes

```{r global_diversity_biased}
# On prépare un dataframe utile pour la richesse spécifique des phylogroupes
df_global_diversity_phylogroup <- longitudinal %>%
  group_by(host) %>%
  distinct(id.clone, .keep_all = TRUE) %>%
  mutate(diversity = n_distinct(group)) %>%
  dplyr::select(host, diversity) %>%
  distinct(host, .keep_all = TRUE) %>%
  ungroup()

df_global_diversity_phylogroup <- metadata %>%
  dplyr::select(-c(11:31, 33:42)) %>%
  rename(host = record_id) %>%
  mutate(host = as.factor(host)) %>%
  left_join(df_global_diversity_phylogroup) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence, age_group, precarity_group, foyer_group, ville_group, sport_group), as.factor)) 
  
df_global_diversity_phylogroup <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  ) %>%
  mutate(
    groupe_event = case_when(
      prise_antibiotique == FALSE & voyage_event == FALSE ~ "Aucun",
      prise_antibiotique == TRUE & voyage_event == FALSE ~ "Antibio seul",
      prise_antibiotique == FALSE & voyage_event == TRUE ~ "Voyage seul",
      prise_antibiotique == TRUE & voyage_event == TRUE ~ "Antibio + Voyage"
    )
  ) %>% 
  dplyr::select(-c(2:3)) %>%
  left_join(df_global_diversity_phylogroup) %>%
  distinct()

df_global_diversity_phylogroup <- df_global_diversity_phylogroup %>%
  mutate(groupe_event = as.factor(groupe_event),
         regime = as.numeric(regime)) %>%
  dplyr::select(-code_postal, -pays_de_naissance, -sport_frequence, -age, -precarity_group, -foyer_group) %>%
  mutate(taille_cm = scale(taille_cm),
         poids = scale(poids)) %>%
  na.omit()

df_global_diversity_phylogroup <- df_global_diversity_phylogroup %>%
  left_join(sample_cohort_df) %>%
  dplyr::select(-host)
```

Maintenant qu'on a créé le jeu de données on va utiliser des modèles linéaires pour expliquer la diversité. On fait une sélection par AICc avec dredge et la variable de débiaisage, comme dans la partie précédente.

```{r global_diversity_biased_lm_mod}
#Selection du meilleur modèle
mod_full <- lm(formula = diversity ~ ., data = df_global_diversity_phylogroup)

# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_diversity_phylogroup_unbiased <- dredge(mod_full, m.lim = c(0, 8),fixed = c("cohort_sample") ,rank = "AICc", cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

best_lm_phylo_diversity <- lm(diversity ~ nombre_enfants + poids + cohort_sample, data = df_global_diversity_phylogroup)

summary(best_lm_phylo_diversity)
Anova(best_lm_phylo_diversity)
```

Ainsi, en considérant la richesse spécifique débiaisé par ajout de variable on a que le nombre d'enfants (l'âge) et le poids sont des variables explicatives de la richesse en phylogroupe pendant la cohorte.

Le sens des coefficients est : 

- Les vieux ont moins de diversité au niveau phylogroupe.
- Les gros ont plus de diversité.

Cette métrique est un petit moins précise que la diversité précédente donc seul les facteurs très significatifs sortent dans l'analyse (plutôt l'âge que le poids d'ailleurs).


## Quelles variables hôtes affectent la diversité

Globalement l'âge ressort beaucoup comme facteur affectant la diversité de sont hôte en terme de souches ou de phylogroupe portés. L'effet semble assez fort et concerne la différence entre les personnes adultes ayant un enfant et les personne n'ayant pas d'enfants. Dans la cohorte ces personnes sont des étudiants. Il y a donc une différence dans la diversité entre les adultes et les étudiants.

Ressortent aussi le poids mais de manière assez peu significative.

Enfin, seulement pour la diversité des souches, sort l'allaitement et la voie d'accouchement qui surprenament pourrait affecter la diversité des adultes. Ces effets ne sont pas très forts mais tout de même sélectionnés de manière significative dans certains modèles.

# Turnover et déterminants hôtes

On va estimer le turnover entre chaque samples pour chaque hôte en calculant la distance de Bray-Curtis entre les samples consécutifs d'un hôte. 

Peut être qu'on pourrait faire la même sur le renouvellement global entre les densités globales de chaque hôte ?

```{r betadiv, fig.width=20}
# Étape 1 : préparation des données
longitudinal_norm <- longitudinal %>%
  group_by(id.sample) %>%
  mutate(rel_abundance = dens.self / sum(dens.self)) %>%
  ungroup()

# Pivot wider avec les abondances relatives
wide <- longitudinal_norm %>%
  dplyr::select(host, id.sample, date, id.clone, rel_abundance) %>%
  pivot_wider(
    names_from = id.clone,
    values_from = rel_abundance,
    values_fill = 0
  )

# Calcul BC pondérée entre samples consécutifs
bc_weighted <- wide %>%
  arrange(host, date) %>% #Tri par hote puis par data
  group_by(host) %>% #Groupement par hote
  group_split() %>% #On sépare les dataframe en sous df qu'on peut utiliser dans la boucle suivante
  map_dfr( function(df_host) {
    if (nrow(df_host) < 2) return(NULL)
    abund <- df_host %>% dplyr::select(-host, -id.sample, -date)
    abund[is.na(abund)] <- 0
    bc <- vegdist(abund, method = "bray")
    bc_mat <- as.matrix(bc)
    
    map_dfr(1:(nrow(df_host)-1), function(i) {
      tibble(
        host = df_host$host[i],
        sample_1 = df_host$id.sample[i],
        date_1 = df_host$date[i],
        sample_2 = df_host$id.sample[i+1],
        date_2 = df_host$date[i+1],
        bray_curtis = bc_mat[i, i+1]
      )
    })
  })

plot_mean_bc <- ggplot(bc_weighted, aes(x = host, y = bray_curtis)) +
    geom_point(aes(x = host), size = 1) +  # Points individuels
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +  # Moyenne en rouge
    theme(legend.position = "none") + 
    ggtitle("Moyenne de la Bray-Curtis distance par hôte")

plot_mean_bc
```

On la moyenne et on rajoute ou pas un effet temps pour voir la robustesse des résultats.

```{r bc_sample}
bc_mean <- bc_weighted %>%
  group_by(host) %>%
  summarise(mean_bray_curtis = mean(bray_curtis))

df_turnover <- df_global_diversity %>%
  left_join(bc_mean)

df_turnover_unbiased <- df_turnover %>%
  left_join(duree_sample_cohort_df) %>% 
  left_join(sample_cohort_df) %>%
  left_join(time_cohort_df)

df_turnover <- df_turnover %>%
  dplyr::select(-diversity, -host)
```

On l'ajoute à un dataframe qu'on va utiliser dans la suite pour les analyses sur le turnover `df_turnover`.

## Visualisation des relations entre turnover moyen des souches et déterminants hôtes

### Turnover et Âge

Pour augmenter la puissance de la variable âge on l'a catégorisé.

```{r age_group_turnover, fig.height=10, fig.width=10}
plot_turnover_age_group <- ggplot(df_turnover, aes(x = age_group, y = mean_bray_curtis, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Age")

plot_turnover_age_group
```

L'âge semble affecter le turnover, les vieux ont moins de turnover que les jeunes.

### Turnover et Score EPICES

```{r turnover_epices, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = mean_bray_curtis, y = score_epices)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Pas vraiment de corrélation.

### Turnover et Régime Alimentaire

```{r turnover_diet, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = regime, y = mean_bray_curtis, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Diet")

p1
```

Les régimes semblent affecter moyennement le turnover.

### Turnover et Sexe

```{r turnover_sex, fig.height=10, fig.width=10}
plot_turnover_sex <- ggplot(df_turnover, aes(x = sex, y = mean_bray_curtis, fill = sex)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Sexe")

plot_turnover_sex
```

Les femmes semblent avoir moins de turnover que les hommes.

### Turnover et Poids

```{r turnover_weigth, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = mean_bray_curtis, y = poids)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Les gens lourds semblent avoir plus de turnover. 

### Turnover et Allaitement

```{r turnover_allaitement, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = allaitement, y = mean_bray_curtis, fill = allaitement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = allaitement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Allaitement")

p1
```

Les personnes non allaitées semblent avoir plus de turnover.

### Turnover et Accouchement

```{r turnover_accouchement, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = voie_accouchement, y = mean_bray_curtis, fill = voie_accouchement)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voie_accouchement), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Voie Accouchement")

p1
```

La voie d'accouchement semble sortir mais est peu significative.

### Turnover et Sport

Voyons si catégoriser la fréquence en Fréquent / Non Fréquent change quelque chose.

```{r turnover_sportgroup, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = sport_group, y = mean_bray_curtis, fill = sport_group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sport_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Sport")

p1
```

La fréquence du sport ne semble pas affecter le turnover des souches.

### Turnover et Nombre Foyer

```{r turnover_foyer, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = nombre_foyer, y = mean_bray_curtis, fill = as.factor(nombre_foyer))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_foyer), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Foyer")

p1
```

Le nombre de personnes dans le foyer semble difficilement influencer le turnover.

### Turnover et Taille

```{r turnover_height, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = mean_bray_curtis, y = taille_cm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=F) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("adj.R2", "p"))) 

p1
```

Il existe une corrélation positive mais celle ci n'est pas du tout significative.

### Turnover et Nombre d'enfants

```{r turnover_enfants, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = nombre_enfants, y = mean_bray_curtis, fill = as.factor(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Enfants")

p1
```

Les personnes ayant des enfants (âgées dans notre cohorte) semblent avoir moins de turnover.

### Turnover et Prise d'antibiotique

```{r turnover_antibio, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = prise_antibiotique , y = mean_bray_curtis, fill = as.factor(prise_antibiotique))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = prise_antibiotique), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Antibio")

p1
```

Les personnes ayant pris un antibiotique semblent avoir moins de turnover que les personnes n'en ayant pas pris.

### Turnover et Voyage

```{r turnover_voyage, fig.height=10, fig.width=10}
p1 <- ggplot(df_turnover, aes(x = voyage_event , y = mean_bray_curtis, fill = as.factor(voyage_event))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = voyage_event), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Turnover et Voyage")

p1
```

Les voyages ne semblent pas vraiment affecter le turnover des souches.

## Modèles linéaires pour le turnover des souches

### Sélection exhaustive par dredge sur l'AICc

```{r lm_turnover_exaustive}
df_turnover[is.nan(df_turnover$mean_bray_curtis), "mean_bray_curtis"] <- NA

# Chez certains hôtes les densités n'ont pas été bien calculé ce qui fait qu'on a pas les turnover.
df_turnover <- na.omit(df_turnover)

mod_full <- lm(formula = mean_bray_curtis ~ ., data = df_turnover)

# Puis lancer votre dredge sur df_clean
# options(na.action = "na.fail")
# cl <- makeCluster(detectCores() - 1)
# dredge_turnover_lm <- dredge(mod_full,
#   rank    = "AICc",
#   cluster = cl, 
#   m.lim = c(0, 8))
# stopCluster(cl)
# options(na.action = "na.omit")
# 
# dredge_turnover_lm_delta <- dredge_turnover_lm[dredge_turnover_lm$delta<2,]
# 
# write.csv(as.data.frame(dredge_turnover_lm_delta), file = "dredge_results_turnover.csv")


#Meilleur modèle par comparaison des AICc
best_turnover_lm <- lm(formula = mean_bray_curtis ~ sex + age_group + nombre_foyer , data = df_turnover) 

summary(best_turnover_lm)
Anova(best_turnover_lm)
```

Cette sélection par AICc donne que le sexe et l'âge ressorent. Le nombre de personnes dans le foyer n'est pas significativement différent de 0.

### Débiaisage du turnover

On va essayer de voir si notre façon de sampler a pu biaiser nos résultats sur le turnover moyen.

On va ajouter peu à peu chaque variable de débiasage dans le meilleur modèle et voir l'effet.

```{r turnover_unbiased_1_}
df_turnover_unbiased[is.nan(df_turnover_unbiased$mean_bray_curtis), "mean_bray_curtis"] <- NA

# Chez certains hôtes les densités n'ont pas été bien calculé ce qui fait qu'on a pas les turnover.
df_turnover_unbiased <- na.omit(df_turnover_unbiased)
  
#Meilleur modèle par comparaison des AIC
best_turnover_unbiased_1 <- lm(formula = mean_bray_curtis ~ sex + age_group + nombre_foyer + temps_moyen_samples, data = df_turnover_unbiased) 

summary(best_turnover_unbiased_1)

best_turnover_unbiased_2 <- lm(formula = mean_bray_curtis ~ sex + age_group + nombre_foyer + cohort_sample, data = df_turnover_unbiased) 

summary(best_turnover_unbiased_2)

best_turnover_unbiased_3 <- lm(formula = mean_bray_curtis ~ sex + age_group + nombre_foyer + cohort_time, data = df_turnover_unbiased) 

summary(best_turnover_unbiased_3)
#AIC(best_turnover)
```

Aucune des variables ne semblent affecter le turnover.

La distance de Bray Curtis moyenne n'est pas affectée fortement par le sampling. On ne va pas inclure de variables de débiaisage.

## Quels déterminants hôtes affectent le turnover moyen des souches ?

Une BC moyenne faible veut dire un petit turnover entre les samples consécutifs.

Le sexe affecte très fortement le turnover moyen des souches entre deux évènements de sampling. Chez les femmes on observe moins de renouvellement entre les souches ce qui parait en cohérence avec les temps plus longs de résidence des souches. 

L'âge semble jouer sur le renouvellement des souches. Plus de renouvellement chez les jeunes que chez les vieux.

# Densité globale des Enterobacterie et déterminants hôtes 

Objectif : expliquer cette variable qui change dans le temps avec le régime par exemple.

```{r density_cohort,fig.height=30, fig.width=30}
plot_density_time <- ggplot(longitudinal, aes(x = date, y = log.density)) + 
    facet_wrap(
    ~host, 
    scales = "free", 
    labeller = labeller(host = function(value) paste0("Host ", value))  # Custom labeller for host
  ) +
  geom_line() + 
  geom_point() +
  xlab("Dates") + 
  ylab("Log.density") +
  theme_bw() +
  theme(
    legend.position = "top",  # Move legend to the top
    legend.direction = "horizontal",  # Make legend horizontal
    legend.box = "horizontal",  # Ensure legend items are in a single row
    text = element_text(size = 10),  # General text size
    axis.text = element_text(size = 6),  # Axis text size
    strip.text = element_text(size = 4),  # Facet label text size
    panel.spacing = unit(1, "lines")  # Adjust spacing between facets
  )

plot_density_time
```

On voit que la densité globale varie mais reste toujours dans les mêmes range en allant d'une forte valeur à une plus faible. Elle fluctue entre les samples. Une moyenne par hôte va donc effacer un peu d'informations mais n'est pas non plus débile.

On va d'abord voir avec des modèles linéaires si la densité globale moyennées sur les samples d'un hôte peuvent être liés à certains facteurs hôtes.

```{r global_dens_df}
# Ajout de la densité moyenne des hôtes
df_global_density <- longitudinal %>%
  group_by(host) %>%
  distinct(id.sample, .keep_all = TRUE) %>%
  mutate(mean.log.density = mean(log.density, na.rm = TRUE)) %>%
  dplyr::select(host, mean.log.density) %>%
  ungroup()

df_global_density[is.nan(df_global_density$mean.log.density), "mean.log.density"] <- NA

df_global_density <- metadata %>%
  dplyr::select(-c(11:31, 33:42)) %>%
  rename(host = record_id) %>%
  mutate(host = as.factor(host)) %>%
  left_join(df_global_density) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence, age_group, precarity_group, foyer_group, ville_group, sport_group), as.factor)) 
  
df_global_density <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  ) %>%
  mutate(
    groupe_event = case_when(
      prise_antibiotique == FALSE & voyage_event == FALSE ~ "Aucun",
      prise_antibiotique == TRUE & voyage_event == FALSE ~ "Antibio seul",
      prise_antibiotique == FALSE & voyage_event == TRUE ~ "Voyage seul",
      prise_antibiotique == TRUE & voyage_event == TRUE ~ "Antibio + Voyage"
    )
  ) %>% 
  left_join(df_global_density) %>%
  distinct()

df_global_density <- df_global_density %>%
  mutate(groupe_event = as.factor(groupe_event),
         regime = as.numeric(regime)) %>%
  dplyr::select(-code_postal, -pays_de_naissance, -sport_frequence, -precarity_group, -foyer_group, -age, -groupe_event, -host) %>%
  mutate(taille_cm = scale(taille_cm),
         poids = scale(poids)) %>%
  na.omit()

df_global_density$age_group <- factor(df_global_density$age_group, levels = c("below_40", "above_40"))
```

## Selection par comparaison exhaustive d'AICc

```{r global_dens_lm}
mod_full <- lm(mean.log.density ~ ., data = df_global_density)

summary(mod_full)

# options(na.action = "na.fail")
# library(parallel)
# cl <- makeCluster(detectCores() - 1)
# dredge_density <- dredge(mod_full, m.lim = c(0, 6), rank = "AICc", cluster = cl)
# stopCluster(cl)
# options(na.action = "na.omit")

# dredge_density_delta <- dredge_density[dredge_density$delta<2,]
# write.csv(as.data.frame(dredge_density_delta), file = "dredge_results_density.csv")

best_lm_density <- lm(mean.log.density ~ age_group + allaitement + nombre_enfants + sex, data = df_global_density)

summary(best_lm_density)
```

Le meilleur modèle sélectionne l'âge (via le groupement et les enfants) et le sexe comme facteurs hôtes avec effets significatifs. L'effet allaitement n'est pas présent (non significatif).

Le coefficient associé à age_group ne représente pas vraiment son effet (à mon avis).

Représentons les facteurs hôtes en fonction de la densité globale moyenne.

## Visualisation des facteurs hôtes importants pour la densité
### Âge et densité globale

```{r age_group_density, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_density, aes(x = age_group, y = mean.log.density, fill = na.omit(age_group))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = age_group), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Densité et Age")

p1
```

On observe beaucoup plus de variabilité de la densité avec l'âge. Les jeunes ont moins de variations que les adultes. En moyenne les adultes semblent avoir moins de diversité mais ceci est très faible. 

### Nombre d'enfants et densité globale

```{r enfants_density, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_density, aes(x = nombre_enfants, y = mean.log.density, fill = na.omit(nombre_enfants))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = nombre_enfants), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Densité et Nombre Enfants")

p1
```

### Sexe et densité globale

```{r sex_density, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_density, aes(x = sex, y = mean.log.density, fill = na.omit(sex))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = sex), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Densité et Sexe")

p1
```

### Régime et densité globale

```{r enfants_density, fig.height=10, fig.width=10}
p1 <- ggplot(df_global_density, aes(x = regime, y = mean.log.density, fill = as.factor(regime))) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(x = regime), shape = ".", size=1) +
    theme(legend.position = "none") + 
    ggtitle("Densité et Régime")

p1
```

## Quels déterminants de la densité globale moyenne ?

On voit que l'âge et le sexe ressortent. Le régime alimentaire ne change pas.

Les femmes auraient plus de densité moyenne des Enterobactérie que les hommes.

Les personnes plus âgées (celles ayant un enfant) auraient une densité moyenne globale plus faible mais surtout plus variable (perte de stabilité du microbiote ?). Ainsi l'âge semble être un facteur qui perturbe la densité moyenne globale.

# Densité propre des souches de E. coli et déterminants hôtes / bactériens

## Proportion de chaque souche dans l'intestin

`df_global_density_self` contient les samples de chaque souche avec leur densité propres sous forme de la proportion que la souche représente dans l'intestin parmi les souches d'E. coli (à peu près, car on ne prend pas toute la diversité de l'intestin), les facteurs hôtes et bactériens associés.

```{r df_dens_self_lm, eval = FALSE}
df_global_density_self <- longitudinal %>%
  group_by(id.sample) %>%
  mutate(prop.density.self = dens.self/sum(dens.self)) %>%
  dplyr::select(host, prop.density.self) %>%
  ungroup()

df_global_density_self[is.nan(df_global_density_self$prop.density.self), "prop.density.self"] <- NA

df_global_density_self <- metadata %>%
  dplyr::select(-c(11:31, 33:42)) %>%
  rename(host = record_id) %>%
  mutate(host = as.factor(host)) %>%
  left_join(df_global_density_self) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence, age_group, precarity_group, foyer_group, ville_group, sport_group), as.factor)) 
  
df_global_density_self <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  ) %>%
  mutate(
    groupe_event = case_when(
      prise_antibiotique == FALSE & voyage_event == FALSE ~ "Aucun",
      prise_antibiotique == TRUE & voyage_event == FALSE ~ "Antibio seul",
      prise_antibiotique == FALSE & voyage_event == TRUE ~ "Voyage seul",
      prise_antibiotique == TRUE & voyage_event == TRUE ~ "Antibio + Voyage"
    )
  ) %>% 
  left_join(df_global_density_self) %>%
  distinct()

df_global_density_self <- df_global_density_self %>%
  mutate(groupe_event = as.factor(groupe_event),
         regime = as.numeric(regime)) %>%
  dplyr::select(-code_postal, -pays_de_naissance, -sport_frequence, -precarity_group, -foyer_group, -age, -groupe_event) %>%
  mutate(taille_cm = scale(taille_cm),
         poids = scale(poids)) %>%
  na.omit()

df_global_density_self$age_group <- factor(df_global_density_self$age_group, levels = c("below_40", "above_40"))
```

On peut voir si cette proportion est expliquée par nos facteurs. 

A faire

## Densité propre de chaque souche dans l'intestin

On peut prendre plus simplement les valeurs de la densité propre et l'expliquer avec nos facteurs. 

A faire.

# Ancien codes à conserver

## ZI selection model
### Interprétation du modèle

Interprétons les coefficients : 

```{r int_zi, fig.height= 20, fig.width= 20}
plot_coeff <- modele_selected_finaliteration %>%
  ggstats::ggcoef_table(
    exponentiate = TRUE,
    intercept = TRUE
  )

plot_coeff
```

Le lien est log chez le count model, on a donc exponentié pour obtenir des valeurs interprétables sous la forme de Risk Ratio. On a aucune variable interprétable car aucune sélectionnée.

Aucun de nos facteurs ne semblent avoir une influence significative sur la partie count. Ceci est cohérent avec les résultats sur les modèles linéaires avec seulement les souches résidentes. On a un fort signal que le temps de résidence d'une souche dans l'intestin après sa mise en place en temps que résidente (+ de 14 jours) est indépendant des facteurs hôtes et bactériens considérés dans notre étude. Ceci est assez étonnant et intéressant.

Le lien est logit chez le ZI model, on a exponentié pour obtenir des Odds Ratio. Les OR sont inversés par rapport à la régression logistique plus haut car avant on prédisait la probabilité d'être résident ou pas alors que là on prédit la probabilité d'être transient ou pas.
On observe une diminution (OR < 1) des probabilités d'être transient chez les phylogroupes traditionnellement résident et les souches ayant une densité focale plus forte que la moyenne. On observe en revanche une augmentation (par rapport à la référence) des probabilités d'être transient chez des personnes avec un nombre plus élevé de personnes dans leur foyer que la moyenne et une densité dans le microbiote plus importante.

Ces résultats sont aussi cohérent avec les facteurs qui sélectionne le fait d'être résident décelé tout à l'heure dans la régression logistique. Cette fois ci l'âge ne sort pas directement (malgré sa présence dans la sélection de modèle) mais le nombre de personnes dans le foyer est certainement corrélé (voir corrélation metadata.rmd)
### Sélection du modèle

Dans un sens avec l'AIC :

```{r selection_zimod_fixed}
# # Sélection manuelle ZI avec zeroinfl (sans effets aléatoires)
# 
# # 1. Préparer les données
# df <- longitudinal_strain_host %>%
#   na.omit() %>%
#   mutate(
#     host           = as.factor(host),
#     log.dens.self  = scale(log.dens.self),
#     log.density    = scale(log.density),
#     age            = scale(age),
#     poids          = scale(poids),
#     taille_cm      = scale(taille_cm),
#     nombre_foyer   = scale(nombre_foyer)
#   ) %>%
#   dplyr::select(-c(
#     mlva, id.clone, residency, residency_scaled_groups,
#     residency_scaled_log_groups, resident_status,
#     date_min, date_max, dates_samples,
#     time_since_start, time_max, age, precarity_group, foyer_group,
#     density, dens.self, code_postal, pays_de_naissance, sport_group, host
#   ))
# 
# df$allaitement <- as.factor(df$allaitement)
# df$voie_accouchement <- as.factor(df$voie_accouchement)
# df$sport_frequence <- as.factor(df$sport_frequence)
# 
# # Recode "group" pour éviter les niveaux rares
# counts <- table(df$group, df$sex)
# rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# df$group <- as.character(df$group)
# df$group[df$group %in% rare_levels] <- "other"
# df$group <- factor(df$group)
# 
# #SELECTION : LONG
# 
# # 2. Définir les variables
# resp    <- "number_event"
# forced  <- c("log.density", "log.dens.self", "group")
# all_terms <- attr(terms(as.formula(paste0(resp, " ~ .")), data = df), "term.labels")
# cand_inflation    <- setdiff(all_terms, forced)
# cand_count <- all_terms
# 
# # 3. Générer combinaisons 1 à 5 pour inflation
# combo_list_inflation <- unlist(
#   lapply(1:5, function(k) combn(cand_inflation, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Générer combinaisons 1 à 5 pour count
# combo_list_count <- unlist(
#   lapply(1:5, function(k) combn(cand_count, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Initialiser le cluster
# ncores <- 6
# cl <- makeCluster(ncores)
# clusterEvalQ(cl, library(pscl))
# clusterExport(cl, c("df", "resp", "forced", "combo_list_inflation"), envir = environment())
# 
# # 5. Selection INFLATION (partie droite du modèle ZI)
# res_zi_list <- parLapply(cl, combo_list_inflation, function(vars) {
#   combo_name <- paste(vars, collapse = " + ")
#   zi_formula <- paste(c(forced, vars), collapse = " + ")
#   tryCatch({
#     m <- zeroinfl(
#       formula = as.formula(paste0(resp, " ~  1 | ", zi_formula)),
#       data = df, dist = "negbin", EM = TRUE
#     )
#     list(combo = combo_name, AIC = AIC(m))
#   }, error = function(e) list(combo = combo_name, AIC = NA))
# })
# 
# # Modèle avec variable forcée seule pour ZI
# base_zi_aic <- tryCatch({
#   m0 <- zeroinfl(
#     formula = as.formula(paste0(resp, " ~  1 | group + log.density + log.dens.self")),
#     data = df, dist = "negbin", EM = TRUE
#   )
#   AIC(m0)
# }, error = function(e) NA)
# 
# res_zi <- bind_rows(
#   tibble(combo = "(none)", AIC = base_zi_aic),
#   bind_rows(lapply(res_zi_list, as_tibble))
# ) %>%
#   filter(!is.na(AIC)) %>%
#   arrange(AIC) %>%
#   mutate(delta = AIC - min(AIC),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("\n=== Sélection ZERO-INFLATION ===\n")
# print(res_zi)
# 
# # 6. Meilleure formule INFLATION
# best_zi_combo <- res_zi$combo[1]
# vars_zi <- if (best_zi_combo == "(none)") character(0) else strsplit(best_zi_combo, " \\+ ")[[1]]
# final_zi_formula <- paste(c(forced, vars_zi), collapse = " + ")
# 
# # 7. Sélection COUNT (partie de gauche du modèle ZI)
# ## Avant parLapply, on exporte aussi final_zi_formula
# clusterExport(cl, c("df", "resp", "forced", "combo_list_count", "final_zi_formula"), envir = environment())
# 
# res_count_list <- parLapply(cl, combo_list_count, function(vars) {
#   count_part <- paste(vars, collapse = " + ")
#   # On assemble l'ensemble en une seule formule
#   f <- as.formula(
#     paste0(resp, " ~ ", count_part, " | ", final_zi_formula)
#   )
#   tryCatch({
#     m <- zeroinfl(f, data = df, dist = "negbin", EM = TRUE)
#     list(combo = count_part, AIC = AIC(m))
#   }, error = function(e) {
#     message("Erreur pour combo ", count_part, " : ", e$message)
#     list(combo = count_part, AIC = NA)
#   })
# })
# 
# # Ajouter modèle de base : number_event ~ group + log.dens + log.self.dens
# base_formula <- as.formula(
#   paste0(resp, " ~ 1 |", final_zi_formula)
# )
# 
# base_aic <- tryCatch({
#   m0 <- zeroinfl(base_formula , data = df, dist = "negbin", EM = TRUE)
#   AIC(m0)
# }, error = function(e) NA)
# 
# res_count <- bind_rows(
#   tibble(combo = "(none)", AIC = base_aic),
#   bind_rows(lapply(res_count_list, as_tibble))
# ) %>%
#   filter(!is.na(AIC)) %>%
#   arrange(AIC) %>%
#   mutate(delta = AIC - min(AIC),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("=== Sélection COUNT ===\n")
# print(res_count)
# 
# # 7. Meilleure formule COUNT
# best_count_combo <- res_count$combo[1]
# vars_count <- if (best_count_combo == "(none)") character(0) else strsplit(best_count_combo, " \\+ ")[[1]]
# final_count_formula <- paste(c(vars_count), collapse = " + ")
# 
# # 8. Ajustement modèle final
# final_formula <- as.formula(
#   paste0(resp, " ~ ", if (final_count_formula == "") "1" else final_count_formula, " | ", final_zi_formula )
# )
# final_model <- zeroinfl(final_formula , data = df, dist = "negbin", EM = TRUE)
# 
# cat("\n=== Résumé du modèle final ===\n")
# summary(final_model)
# 
# # 9. Stopper le cluster
# stopCluster(cl)
# 
# # best_zibin_aic_1 <- zeroinfl(number_event ~ log.density + log.dens.self + group + poids | log.density + log.dens.self + group + regime + nombre_foyer, data = df, dist = "negbin", EM = TRUE)
# # 
# # summary(best_zibin_aic_1)
```

Dans l'autre sens avec AIC en fixant les variables pour inflation :

```{r selection_zimod_fixed_othersense}
# # Sélection manuelle ZI avec zeroinfl (sans effets aléatoires)
# 
# # 1. Préparer les données
# df <- longitudinal_strain_host %>%
#   na.omit() %>%
#   mutate(
#     host           = as.factor(host),
#     log.dens.self  = scale(log.dens.self),
#     log.density    = scale(log.density),
#     age            = scale(age),
#     poids          = scale(poids),
#     taille_cm      = scale(taille_cm),
#     nombre_foyer   = scale(nombre_foyer)
#   ) %>%
#   dplyr::select(-c(
#     mlva, id.clone, residency, residency_scaled_groups,
#     residency_scaled_log_groups, resident_status,
#     date_min, date_max, dates_samples,
#     time_since_start, time_max, age, precarity_group, foyer_group,
#     density, dens.self, code_postal, pays_de_naissance, sport_group, host
#   ))
# 
# df$allaitement <- as.factor(df$allaitement)
# df$voie_accouchement <- as.factor(df$voie_accouchement)
# df$sport_frequence <- as.factor(df$sport_frequence)
# 
# # Recode "group" pour éviter les niveaux rares
# counts <- table(df$group, df$sex)
# rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# df$group <- as.character(df$group)
# df$group[df$group %in% rare_levels] <- "other"
# df$group <- factor(df$group)
# 
# #SELECTION : LONG
# 
# # 2. Définir les variables
# resp    <- "number_event"
# forced  <- c("log.density", "log.dens.self", "group")
# all_terms <- attr(terms(as.formula(paste0(resp, " ~ .")), data = df), "term.labels")
# cand_inflation    <- setdiff(all_terms, forced)
# cand_count <- all_terms
# 
# # 3. Générer combinaisons 1 à 5 pour inflation
# combo_list_inflation <- unlist(
#   lapply(1:5, function(k) combn(cand_inflation, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Générer combinaisons 1 à 5 pour count
# combo_list_count <- unlist(
#   lapply(1:5, function(k) combn(cand_count, k, simplify = FALSE)),
#   recursive = FALSE
# )
# 
# # 4. Initialiser le cluster
# ncores <- 6
# cl <- makeCluster(ncores)
# clusterEvalQ(cl, library(pscl))
# 
# # clusterExport(cl, c("df", "resp", "forced", "combo_list_count"), envir = environment())
# # 
# # # 5. Selection COUNT (partie gauche du modèle ZI)
# # res_count_list <- parLapply(cl, combo_list_count, function(vars) {
# #   combo_name <- paste(vars, collapse = " + ")
# #   count_formula <- paste(vars, collapse = " + ")
# #   tryCatch({
# #     m <- zeroinfl(
# #       formula = as.formula(paste0(resp, " ~", count_formula ,"| 1")),
# #       data = df, dist = "negbin", EM = TRUE
# #     )
# #     list(combo = combo_name, AICc = AICc(m))
# #   }, error = function(e) list(combo = combo_name, AIC = NA))
# # })
# # 
# # # Modèle avec variable forcée seule pour count
# # base_count_aic <- tryCatch({
# #   m0 <- zeroinfl(
# #     formula = as.formula(paste0(resp, " ~  1 | 1")),
# #     data = df, dist = "negbin", EM = TRUE
# #   )
# #   AICc(m0)
# # }, error = function(e) NA)
# # 
# # res_count <- bind_rows(
# #   tibble(combo = "(none)", AICc = base_count_aic),
# #   bind_rows(lapply(res_count_list, as_tibble))
# # ) %>%
# #   filter(!is.na(AICc)) %>%
# #   arrange(AICc) %>%
# #   mutate(delta = AICc - min(AICc),
# #          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# # 
# # cat("\n=== Sélection Count ===\n")
# # print(res_count)
# # 
# # # 6. Meilleure formule INFLATION
# # best_count_combo <- res_count$combo[1]
# # vars_count <- if (best_count_combo == "(none)") "1" else strsplit(best_count_combo, " \\+ ")[[1]]
# #final_count_formula <- paste(c(vars_count, collapse = " + "))
# final_count_formula <- "group + log.density + log.dens.self"
# 
# # 7. Sélection ZI (partie de droite du modèle ZI)
# ## Avant parLapply, on exporte aussi final_count_formula
# clusterExport(cl, c("df", "resp", "forced", "combo_list_inflation", "final_count_formula"), envir = environment())
# 
# # On fixe certaines variable dont on est sur qu'elles vont sortir
# res_zi_list <- parLapply(cl, combo_list_inflation, function(vars) {
#   zi_part <-  paste(c(forced, vars), collapse = " + ")
#   # On assemble l'ensemble en une seule formule
#   f <- as.formula(
#     paste0(resp, " ~ ", final_count_formula, " | ", zi_part)
#   )
#   tryCatch({
#     m <- zeroinfl(f, data = df, dist = "negbin", EM = TRUE)
#     list(combo = zi_part, AICc = AICc(m))
#   }, error = function(e) {
#     message("Erreur pour combo ", zi_part, " : ", e$message)
#     list(combo = zi_part, AICc = NA)
#   })
# })
# 
# # Ajouter modèle de base : number_event ~ count_best | 1
# base_formula <- as.formula(
#   paste0(resp, " ~",  final_count_formula ,"| 1")
# )
# 
# base_aic <- tryCatch({
#   m0 <- zeroinfl(base_formula , data = df, dist = "negbin", EM = TRUE)
#   AICc(m0)
# }, error = function(e) NA)
# 
# res_zi <- bind_rows(
#   tibble(combo = "(none)", AICc = base_aic),
#   bind_rows(lapply(res_zi_list, as_tibble))
# ) %>%
#   filter(!is.na(AICc)) %>%
#   arrange(AICc) %>%
#   mutate(delta = AICc - min(AICc),
#          weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta)))
# 
# cat("=== Sélection ZI ===\n")
# print(res_zi)
# 
# # 7. Meilleure formule ZI Si fixation de forced alors "1" devient character(0)
# best_zi_combo <- res_zi$combo[1]
# vars_zi <- if (best_zi_combo == "(none)") "1" else strsplit(best_zi_combo, " \\+ ")[[1]]
# final_zi_formula <- paste(c(forced, vars_zi), collapse = " + ")
# 
# # 8. Ajustement modèle final
# final_formula <- as.formula(
#   paste0(resp, " ~ ", if (final_count_formula == "") "1" else final_count_formula, " | ", final_zi_formula)
# )
# final_model <- zeroinfl(final_formula , data = df, dist = "negbin", EM = TRUE)
# 
# cat("\n=== Résumé du modèle final ===\n")
# summary(final_model)
# 
# # 9. Stopper le cluster
# stopCluster(cl)
# 
# best_zibin_aic_2 <- zeroinfl(number_event ~ log.density + log.dens.self + group  | regime + nombre_foyer, data = df, dist = "negbin", EM = TRUE)
# 
# summary(best_zibin_aic_2)
```

```{r a_lancer_en_premier_first_count, eval = FALSE}
# Lancer ca, voir si besoin de faire group_new pour sex et voie accouchement. 
# Hypothèse : facteur mixte hôte n'est pas significatif (facilite bcp la selection).
# Problème d'avant : la partie ZI ne convergeait pas donc j'ai changé de methode de modèle (enlever le facteur mixte et donc passer a zeroinfl()). Si ca marche pas en parler avec TMJ et voir si je le présente dans le rapport. Ou alors si je fais la selection avec stepAIC. OU enorme dredge sur le cluster. Parler du problème de regression step analysis avec TMJ.

# ========================================
# Sélection manuelle ZI avec zeroinfl (sans effets aléatoires)
# ========================================

#Effet mixte change la puissance mais pas le sens, donc enlever l'effet alétoire et faire selection forward et backward a lamin avec Anova().

# 0. Packages nécessaires
library(pscl)
library(dplyr)
library(parallel)
library(tibble)

# 1. Préparer les données (comme avant, mais sans (1|host))
df_2 <- longitudinal_strain_host %>%
  na.omit() %>%
  mutate(
    host           = as.factor(host),
    log.dens.self  = scale(log.dens.self),
    log.density    = scale(log.density),
    age            = scale(age),
    poids          = scale(poids),
    taille_cm      = scale(taille_cm),
    nombre_foyer   = scale(nombre_foyer)
  ) %>%
  dplyr::select(-c(
    mlva, id.clone, residency, residency_scaled_groups,
    residency_scaled_log_groups, resident_status,
    date_min, date_max, dates_samples,
    time_since_start, time_max,
    age_group, precarity_group, foyer_group,
    density, dens.self, code_postal, pays_de_naissance,
    nombre_enfants, sport_group, ville_group, host
  ))

# Recode "group" pour éviter les niveaux rares
counts_2 <- table(df_2$group, df_2$sex)
rare_levels_2 <- rownames(counts_2)[apply(counts_2, 1, function(x) any(x <= 2))]
df_2$group <- as.character(df_2$group)
df_2$group[df_2$group %in% rare_levels_2] <- "other"
df_2$group <- factor(df_2$group)

# 2. Définir les variables
resp_2     <- "number_event"
forced_2   <- c("log.density", "log.dens.self", "group")
all_terms_2 <- attr(terms(as.formula(paste0(resp_2, " ~ .")), data = df_2), "term.labels")
cand_2     <- setdiff(all_terms_2, forced_2)

# 3. Générer combinaisons 1 à 5
combo_list_2 <- unlist(
  lapply(1:5, function(k) combn(cand_2, k, simplify = FALSE)),
  recursive = FALSE
)

# 4. Initialiser le cluster
ncores_2 <- 6
cl_2     <- makeCluster(ncores_2)
clusterEvalQ(cl_2, library(pscl))
clusterExport(cl_2, c("df_2", "resp_2", "forced_2", "combo_list_2"), envir = environment())

# 5. Sélection COUNT (partie de gauche du modèle ZI)
res_count_list_2 <- parLapply(cl_2, combo_list_2, function(vars) {
  combo_name <- paste(vars, collapse = " + ")
  f_count <- as.formula(
    paste0(
      resp_2,
      " ~ ",
      paste(c(forced_2, vars), collapse = " + "),
      " | ",
      "group + log.density + log.dens.self"
    )
  )
  tryCatch({
    m_2 <- zeroinfl(f_count, data = df_2, dist = "negbin", EM = TRUE)
    list(combo = combo_name, AIC = AIC(m_2))
  }, error = function(e) list(combo = combo_name, AIC = NA))
})

# Ajouter modèle de base
base_formula_2 <- as.formula(
  paste0(
    resp_2,
    " ~ ",
    paste(forced_2, collapse = " + "),
    " | ",
    "group + log.density + log.dens.self"
  )
)
base_aic_2 <- tryCatch({
  m0_2 <- zeroinfl(base_formula_2, data = df_2, dist = "negbin", EM = TRUE)
  AIC(m0_2)
}, error = function(e) NA)

res_count_2 <- bind_rows(
  tibble(combo = "(none)", AIC = base_aic_2),
  bind_rows(lapply(res_count_list_2, as_tibble))
) %>%
  arrange(AIC) %>%
  mutate(
    delta  = AIC - min(AIC),
    weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta))
  )

cat("=== Sélection COUNT ===\n")
print(res_count_2)

# 6. Meilleure formule COUNT
best_count_combo_2    <- res_count_2$combo[1]
vars_count_2          <- if (best_count_combo_2 == "(none)") character(0) else strsplit(best_count_combo_2, " \\+ ")[[1]]
final_count_formula_2 <- paste(c(forced_2, vars_count_2), collapse = " + ")

# 7. Sélection ZI (partie droite du modèle)
clusterExport(cl_2, c("df_2", "resp_2", "forced_2", "combo_list_2", "final_count_formula_2"), envir = environment())

res_zi_list_2 <- parLapply(cl_2, combo_list_2, function(vars) {
  combo_name <- paste(vars, collapse = " + ")
  f_zi <- as.formula(
    paste0(
      resp_2,
      " ~ ",
      final_count_formula_2,
      " | ",
      paste(c(forced_2, vars), collapse = " + ")
    )
  )
  tryCatch({
    m_zi_2 <- zeroinfl(f_zi, data = df_2, dist = "negbin", EM = TRUE)
    list(combo = combo_name, AIC = AIC(m_zi_2))
  }, error = function(e) list(combo = combo_name, AIC = NA))
})

# Modèle avec intercept seul pour ZI
base_zi_aic_2 <- tryCatch({
  m0_zi_2 <- zeroinfl(
    formula = as.formula(paste0(resp_2, " ~ ", final_count_formula_2, " | group + log.density + log.dens.self")),
    data = df_2, dist = "negbin", EM = TRUE
  )
  AIC(m0_zi_2)
}, error = function(e) NA)

res_zi_2 <- bind_rows(
  tibble(combo = "(none)", AIC = base_zi_aic_2),
  bind_rows(lapply(res_zi_list_2, as_tibble))
) %>%
  arrange(AIC) %>%
  mutate(
    delta  = AIC - min(AIC),
    weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta))
  )

cat("\n=== Sélection ZERO-INFLATION ===\n")
print(res_zi_2)

# 8. Ajustement modèle final
best_zi_combo_2     <- res_zi_2$combo[1]
vars_zi_2           <- if (best_zi_combo_2 == "(none)") "group + log.density + log.dens.self" else paste(c(forced_2, strsplit(best_zi_combo_2, " \\+ ")[[1]]), collapse = " + ")
final_formula_2     <- as.formula(paste0(resp_2, " ~ ", final_count_formula_2, " | ", vars_zi_2))
final_model_2       <- zeroinfl(final_formula_2, data = df_2, dist = "negbin", EM = TRUE)

cat("\n=== Résumé du modèle final ===\n")
summary(final_model_2)

# 9. Stopper le cluster
stopCluster(cl_2)
```

```{r poubelle_zimod}
#Essai avec Hurdle model, ce modèle ne converge pas
#mod_hurdle_best <- hurdle(formula = number_event ~ group + log.density + log.dens.self + sex, data = zi_df, dist = "negbin")
#summary(mod_hurdle_best)

#Essai avec glmmTMB pour les modèles mixtes et ZI géométrique 

# On fixe le theta à 1 ce qui a effet de forcer une distribution de comptage en loi géométrique.

#best_zibin_1 <- glmmTMB(
#  number_event ~ group_new + log.density.sc + log.dens.self.sc + sex,
#  family = nbinom2,
#  data = zi_df,
#  ziformula = ~ group_new + log.density.sc + log.dens.self.sc + sex
#)

#summary(best_zibin_1) 

# Meilleur modèle par comparaison de AIC :MARCHE PAS
#best_model_zinegbin <- glmmTMB(number_event ~ group + log.density + log.dens.self + regime + score_epices + sex + age + taille_cm + poids + nombre_foyer  + ville_group + prise_antibiotique + voyage_event, family = nbinom2, start = list(theta = 1), map = list(theta = factor(NA)), data = zi_df,ziformula = ~ group + log.density + log.dens.self + regime + score_epices + sex + age + taille_cm + poids + nombre_foyer + ville_group + prise_antibiotique + voyage_event)
#summary(best_model_zinegbin)
#Anova(best_model_zinegbin, type = 3)

#options(na.action = "na.fail")
#Selection du meilleur modèle (très long) MARCHE PAS
#library(parallel)
#cl <- makeCluster(detectCores() - 1)
#dredge_res_resident <- dredge(mod_full, m.lim = c(0, 5), cluster = cl)
#stopCluster(cl) 
#options(na.action = "na.omit")
```

```{r, eval = FALSE}
zi_df <- longitudinal_strain_host

zi_df <- na.omit(zi_df)

#On ajoute les densités scalées
zi_df$log.dens.self.sc <- scale(zi_df$log.dens.self)
zi_df$log.density.sc <- scale(zi_df$log.density)
zi_df$taille_cm <- scale(zi_df$taille_cm, scale=F)
zi_df$nombre_foyer <- scale(zi_df$nombre_foyer, scale = F)

zi_df$mlva <- NULL
zi_df$id.clone <- NULL
zi_df$host <- NULL
zi_df$residency <- NULL
zi_df$residency_scaled_groups <- NULL
zi_df$residency_scaled_log_groups <- NULL
zi_df$resident_status <- NULL
zi_df$date_min <- NULL
zi_df$date_max <- NULL
zi_df$dates_samples <- NULL
zi_df$time_since_start <- NULL
zi_df$time_max <- NULL

#zi_df$age_group <- NULL
zi_df$precarity_group <- NULL
zi_df$foyer_group <- NULL
zi_df$sport_group <- NULL
zi_df$density <- NULL
zi_df$dens.self <- NULL
zi_df$code_postal <- NULL
zi_df$pays_de_naissance <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zi_df$group, zi_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zi_df$group_new <- as.character(zi_df$group)
zi_df$group_new[zi_df$group_new %in% rare_levels] <- "other"
zi_df$group_new <- factor(zi_df$group_new)

#Pour la convergence et le calcul des pvalue
zi_df$group <- NULL
zi_df$log.density <- NULL
zi_df$log.dens.self <- NULL

#Modèle basé sur les anciennes estimations : séparement on estime quels sont les meilleurs modèles
#best_zibin_prec <- zeroinfl(formula = number_event ~ sex + taille_cm + log.dens.self.sc + log.density.sc +  group_new | sex + nombre_foyer + log.dens.self.sc + log.density.sc + group_new, data = zi_df, dist = "negbin")
#summary(best_zibin_prec)

# Selection du meilleur modèle
#mod_full <- zeroinfl(number_event ~ . | ., dist = "negbin", data = zi_df)
#stepAIC(mod_full, direction = "both") #Selection backward-forward selectionne le sex et le nbr foyer ainsi que les densités dans le meilleur modèle.
```

Essai avec ZI Neg Bin with mixed effect : On ne peut pas utiliser de package directement. Il faut tout coder à la main.

A LANCER

```{r test_1, eval=FALSE}
#DF : 
zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL
#zinbm_df$log.density <- NULL
#zinbm_df$log.dens.self <- NULL
```

```{r partie2, eval = FALSE}
install.packages(glmmTMB)
library(glmmTMB)

# Define your full predictor list faire names 
predictors <- c(group_new, log.density , log.dens.self, voie_accouchement, allaitement, nombre_enfants, regime , score_epices , sex , age , taille_cm, poids, nombre_foyer, ville_group, sport_group, prise_antibiotique, voyage_event)

# Generate all combinations of predictors
predictor_combinations <- unlist(
  lapply(1:length(predictors), function(n) combn(predictors, n, simplify = FALSE)),
  recursive = FALSE
)

# Add full model as last
predictor_combinations <- c(predictor_combinations, list(predictors))

# Initialize list to store models and AICs
model_list <- list()
aic_table <- data.frame(ModelID = character(), AIC = numeric(), Formula = character(), stringsAsFactors = FALSE)

# Loop through combinations
for (i in seq_along(predictor_combinations)) {
  vars <- predictor_combinations[[i]]
  fixed_formula <- as.formula(paste("count ~", paste(vars, collapse = " + "), "+ (1 | subject)"))
  zi_formula <- as.formula(paste("~", paste(vars, collapse = " + "), "+ (1 | subject)"))

  # Fit model
  fit <- try(glmmTMB(
    formula = fixed_formula,
    ziformula = zi_formula,
    family = nbinom2,
    data = zinbm_df
  ), silent = TRUE)

  # If fit succeeds, store
  if (!inherits(fit, "try-error")) {
    model_id <- paste0("Model_", i)
    model_list[[model_id]] <- fit
    aic_val <- AIC(fit)
    aic_table <- rbind(aic_table, data.frame(
      ModelID = model_id,
      AIC = aic_val,
      Formula = paste(vars, collapse = " + ")
    ))
  }
}

# Sort models by AIC
aic_table <- aic_table[order(aic_table$AIC), ]
print(aic_table)

# Access best model
best_model_id <- aic_table$ModelID[1]
best_model <- model_list[[best_model_id]]
summary(best_model)
```

```{r test_2, eval=FALSE}
zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL
#zinbm_df$log.density <- NULL
#zinbm_df$log.dens.self <- NULL

# Chargement des packages nécessaires
library(pscl)
library(MASS)

# Liste des variables candidates
vars <- c("group_new", "log.density", "log.dens.self", "voie_accouchement", "allaitement", "nombre_enfants", "regime", "score_epices", "sex", "age", "taille_cm", "poids", "nombre_foyer", "ville_group", "sport_group", "prise_antibiotique","voyage_event")

# Étape 1 : Sélection des variables pour la partie COMPTAGE
# ------------------------------------------------------------------

# Créer la formule de départ (toutes les variables dans les deux parties)
form_full <- as.formula(paste0("number_event ~ ", paste(vars, collapse = " + "),
                               " | ", paste(vars, collapse = " + ")))

zinbm_df$log.density     <- as.numeric(zinbm_df$log.density)
zinbm_df$log.dens.self   <- as.numeric(zinbm_df$log.dens.self)
zinbm_df$age             <- as.numeric(zinbm_df$age)
zinbm_df$taille_cm       <- as.numeric(zinbm_df$taille_cm)
zinbm_df$poids           <- as.numeric(zinbm_df$poids)
zinbm_df$nombre_foyer    <- as.numeric(zinbm_df$nombre_foyer)

# Ajuster le modèle complet
full_model <- zeroinfl(form_full, data = zinbm_df, dist = "negbin")

# Sélection uniquement sur la partie COMPTAGE :
# En fixant la partie logistique (~1), on fait la sélection sur la partie NB
form_count_only <- as.formula(paste0("number_event ~ ", paste(vars, collapse = " + "), " | 1"))
model_count <- zeroinfl(form_count_only, data = zinbm_df, dist = "negbin")

# Stepwise AIC sur la partie comptage
step_count <- stepAIC(full_model,
                      scope = list(lower = ~1, upper = as.formula(paste("~", paste(vars, collapse = " + ")))),
                      direction = "both",
                      trace = T)

# Extraire les variables sélectionnées
count_terms <- attr(terms(formula(step_count)), "term.labels")

# Étape 2 : Sélection des variables pour la partie LOGISTIQUE
# ------------------------------------------------------------------

# Fixer la partie comptage avec les variables sélectionnées
count_formula_str <- paste(count_terms, collapse = " + ")
form_zi_full <- as.formula(paste0("number_event ~ ", count_formula_str, " | ", paste(vars, collapse = " + ")))

model_zi <- zeroinfl(form_zi_full, data = zinbm_df, dist = "negbin")

# Stepwise AIC sur la partie logistique
step_zi <- stepAIC(model_zi,
                   scope = list(lower = ~1, upper = as.formula(paste("~", paste(vars, collapse = " + ")))),
                   direction = "both",
                   trace = FALSE)

count_terms_zi <- attr(terms(formula(step_zi)), "term.labels")


# Résultat final
summary(step_zi)
```

```{r test_3.1, eval = FALSE}
zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

#Pour ZI model : 
zinbm_df$nombre_enfants <- NULL
zinbm_df$sport_group <- NULL
zinbm_df$ville_group <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL
#zinbm_df$log.density <- NULL
#zinbm_df$log.dens.self <- NULL

library(glmmTMB)
library(parallel)

# Variables fixes à inclure dans tous les modèles
fixed_vars <- c("group_new", "log.density", "log.dens.self")

# Autres variables à combiner
optional_vars <- c("voie_accouchement", "allaitement", "nombre_enfants", "regime",
                   "score_epices", "sex", "age", "taille_cm", "poids", "nombre_foyer",
                   "ville_group", "sport_group", "prise_antibiotique", "voyage_event")

max_comb_vars <- 5

predictor_combinations <- unlist(
  lapply(0:min(max_comb_vars, length(optional_vars)), function(n) {
    combn(optional_vars, n, simplify = FALSE)
  }),
  recursive = FALSE
)

# Créer toutes les paires de fixed_formula et zi_formula indépendantes
model_specs <- expand.grid(
  fixed = predictor_combinations,
  zi = predictor_combinations,
  stringsAsFactors = FALSE
)

# Fonction pour ajuster un modèle
fit_model <- function(row_id) {
  vars_fixed <- c(fixed_vars, model_specs$fixed[[row_id]])
  vars_zi <- c(fixed_vars, model_specs$zi[[row_id]])
  
  fixed_formula <- as.formula(paste("number_event ~", paste(vars_fixed, collapse = " + "), "+ (1 | host)"))
  zi_formula <- as.formula(paste("~", paste(vars_zi, collapse = " + "),"+ (1 | host)"))

  fit <- try(glmmTMB(
    formula = fixed_formula,
    ziformula = zi_formula,
    family = nbinom2,
    data = zinbm_df
  ), silent = TRUE)

  if (!inherits(fit, "try-error")) {
    return(list(
      model_id = paste0("Model_", row_id),
      aic = AIC(fit),
      formula_fixed = paste(vars_fixed, collapse = " + "),
      formula_zi = paste(vars_zi, collapse = " + "),
      fit = fit
    ))
  } else {
    return(NULL)
  }
}

# Utiliser 7 cœurs
results <- mclapply(1:nrow(model_specs), fit_model, mc.cores = 7)

# Nettoyer les résultats
results <- Filter(Negate(is.null), results)

# Extraire les AICs
aic_table <- do.call(rbind, lapply(results, function(res) {
  data.frame(
    ModelID = res$model_id,
    AIC = res$aic,
    FixedFormula = res$formula_fixed,
    ZIFormula = res$formula_zi,
    stringsAsFactors = FALSE
  )
}))

# Trier par AIC
aic_table <- aic_table[order(aic_table$AIC), ]
print(head(aic_table, 10))  # top 10

# Accès au meilleur modèle
best_model <- results[[which.min(sapply(results, function(res) res$aic))]]$fit
summary(best_model)
```

```{r test_3.2, eval = FALSE}
library(glmmTMB)
library(parallel)

# Variables fixes à inclure dans tous les modèles
fixed_vars <- c("group_new", "log.density", "log.dens.self")

# Autres variables à combiner
optional_vars <- c("voie_accouchement", "allaitement", "nombre_enfants", "regime",
                   "score_epices", "sex", "age", "taille_cm", "poids", "nombre_foyer",
                   "ville_group", "sport_group", "prise_antibiotique", "voyage_event")

# Générer les combinaisons jusqu'à 8 variables parmi optional_vars
max_comb_vars <- 8
predictor_combinations <- unlist(
  lapply(0:min(max_comb_vars, length(optional_vars)), function(n) {
    combn(optional_vars, n, simplify = FALSE)
  }),
  recursive = FALSE
)

# Créer toutes les paires de fixed_formula et zi_formula indépendantes
model_specs <- expand.grid(
  fixed = predictor_combinations,
  zi = predictor_combinations,
  stringsAsFactors = FALSE
)

# Fonction pour ajuster un modèle
fit_model <- function(row_id) {
  vars_fixed <- c(fixed_vars, model_specs$fixed[[row_id]])
  vars_zi <- c(fixed_vars, model_specs$zi[[row_id]])
  
  fixed_formula <- as.formula(paste("count ~", paste(vars_fixed, collapse = " + "), "+ (1 | subject)"))
  zi_formula <- as.formula(paste("~", paste(vars_zi, collapse = " + ")))

  fit <- try(glmmTMB(
    formula = fixed_formula,
    ziformula = zi_formula,
    family = nbinom2,
    data = zinbm_df
  ), silent = TRUE)

  if (!inherits(fit, "try-error")) {
    return(list(
      model_id = paste0("Model_", row_id),
      aic = AIC(fit),
      formula_fixed = paste(vars_fixed, collapse = " + "),
      formula_zi = paste(vars_zi, collapse = " + "),
      fit = fit
    ))
  } else {
    return(NULL)
  }
}

# Utiliser 7 cœurs
results <- mclapply(1:nrow(model_specs), fit_model, mc.cores = 7)

# Nettoyer les résultats
results <- Filter(Negate(is.null), results)

# Extraire les AICs
aic_table <- do.call(rbind, lapply(results, function(res) {
  data.frame(
    ModelID = res$model_id,
    AIC = res$aic,
    FixedFormula = res$formula_fixed,
    ZIFormula = res$formula_zi,
    stringsAsFactors = FALSE
  )
}))

# Trier par AIC
aic_table <- aic_table[order(aic_table$AIC), ]
print(head(aic_table, 10))  # top 10

# Accès au meilleur modèle
best_model <- results[[which.min(sapply(results, function(res) res$aic))]]$fit
summary(best_model)
```

```{r pitie, eval = FALSE}
# TROP LONG 3473² modèles testés

zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

#Pour ZI model : 
zinbm_df$nombre_enfants <- NULL
zinbm_df$sport_group <- NULL
zinbm_df$ville_group <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL

# 0. Charger les packages
library(glmmTMB)   # pour glmmTMB()
library(MuMIn)     # pour dredge()
library(parallel)  # pour makeCluster()

# 1. Préparation
df      <- zinbm_df
resp    <- "number_event"
forced  <- c("log.density", "log.dens.self", "group_new")
allVars <- setdiff(names(df), c(resp, "host"))
cand    <- setdiff(allVars, forced)

# 2. Formules séparées
count_form <- as.formula(
  paste0(resp, " ~ ", paste(c(forced, cand), collapse = " + "), " + (1|host)")
)
zi_form <- as.formula(
  paste0("~ ", paste(c(forced, cand), collapse = " + "), " + (1|host)")
)

# 3. Ajustement du modèle “full” ZI‑mixte en multicœur
mod_full <- glmmTMB(
  formula = count_form,
  zi      = zi_form,
  family  = nbinom2,
  data    = df
)

# 4. Préparer le cluster de 6 cœurs
cl <- makeCluster(6)
clusterEvalQ(cl, {
  library(glmmTMB)
  library(MuMIn)
})
clusterExport(cl, "mod_full")

# 5. Dredge en parallèle : CE QUI SEXECUTE
options(na.action = "na.fail")  # requis par MuMIn
dredged <- dredge(
  mod_full,
  fixed = forced,          # variables toujours présentes
  m.lim = c(length(forced), 8),
  rank  = "AIC",
  cluster = cl
)

# 6. Fermer le cluster
stopCluster(cl)

# 7. Récupérer et afficher le meilleur modèle
best_mod <- get.models(dredged, 1)[[1]]
summary(best_mod)

# 8. CE QUI MINTERESSE ABDEL Aperçu des 10 meilleurs modèles
print(head(dredged, 10))
```


```{r dernier_select_moyen_fiable, eval = FALSE}
# Sélection séquentielle de modèles ZI-glmmTMB

# 0. Charger les packages
library(glmmTMB)
library(MuMIn)
library(parallel)

zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

#Pour ZI model : 
zinbm_df$nombre_enfants <- NULL
zinbm_df$sport_group <- NULL
zinbm_df$ville_group <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL

# 1. Préparation
df      <- zinbm_df
resp    <- "number_event"
forced  <- c("log.density", "log.dens.self", "group_new")
allVars <- setdiff(names(df), c(resp, "host"))
cand    <- setdiff(allVars, forced)

# 2. Formule de base pour count et zi
# zi intercept-only + random effect
zi_base <- as.formula(paste0("~ 1 + (1| host)"))
# count avec toutes les variables forcées et candidates
count_full <- as.formula(
  paste0(resp, " ~ ", paste(c(forced, cand), collapse = " + "), " + (1|host)")
)

# 3. Initialiser le cluster pour dredge
cl <- makeCluster(6)
clusterEvalQ(cl, {
  library(glmmTMB)
  library(MuMIn)
})
options(na.action = "na.fail")

# 4. Étape 1 : Dredge sur la partie count (zi intercept-only), max 8 variables dont les 3 forcées
mod_count_initial <- glmmTMB(
  formula = count_full,
  zi      = zi_base,
  family  = nbinom2,
  data    = df
)

dredge_count_2 <- dredge(
  mod_count_initial,
  fixed   = forced,
  m.lim   = c(length(forced), length(forced) + 5),  # min = 3, max = 8 variables
  rank    = "AIC",
  cluster = cl
)

# Extraire le meilleur modèle count
best_count_2 <- get.models(dredge_count_2, 1)[[1]]
message("Formule count sélectionnée : ")
print(formula(best_count))
```


```{r dernier_select_moyen_fiable_partie2, eval = FALSE}
# Extraire le meilleur modèle count
best_count <- get.models(dredge_count, 1)[[1]]
message("Formule count sélectionnée : ")
print(formula(best_count))

# 5. Étape 2 : Dredge sur la partie zi (count fixé), même limite
mod_zi_full <- glmmTMB(
  formula = count_selected,
  zi      = zi_full,
  family  = nbinom2,
  data    = df
)
dredge_zi <- dredge(
  mod_zi_full,
  fixed   = forced,
  m.lim   = c(length(forced), length(forced) + 5),  # toujours max 8 variables
  rank    = "AIC",
  cluster = cl
)
# Extraire le meilleur modèle zi
best_zi <- get.models(dredge_zi, 1)[[1]]
message("Formule zi sélectionnée : ")
print(ziformula(best_zi))

# 6. Arrêter le cluster
stopCluster(cl)

# 7. Résumé du meilleur modèle ZI-mixte
summary(best_zi)
```


```{r dernier_select_moyen_fiable_2_groupdifferent, eval = FALSE}
# Sélection séquentielle de modèles ZI-glmmTMB

# 0. Charger les packages
library(glmmTMB)
library(MuMIn)
library(parallel)

zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

#Pour ZI model : 
zinbm_df$nombre_enfants <- NULL
zinbm_df$sport_group <- NULL
zinbm_df$ville_group <- NULL

# 1. Préparation
df      <- zinbm_df
resp    <- "number_event"
forced  <- c("log.density", "log.dens.self", "group")
allVars <- setdiff(names(df), c(resp, "host"))
cand    <- setdiff(allVars, forced)

# 2. Formule de base pour count et zi
# zi intercept-only + random effect
zi_base <- as.formula(paste0("~ 1 + (1| host)"))
# count avec toutes les variables forcées et candidates
count_full <- as.formula(
  paste0(resp, " ~ ", paste(c(forced, cand), collapse = " + "), " + (1|host)")
)

# 3. Initialiser le cluster pour dredge
cl <- makeCluster(6)
clusterEvalQ(cl, {
  library(glmmTMB)
  library(MuMIn)
})
options(na.action = "na.fail")

# 4. Étape 1 : Dredge sur la partie count (zi intercept-only), max 8 variables dont les 3 forcées
mod_count_initial <- glmmTMB(
  formula = count_full,
  zi      = zi_base,
  family  = nbinom2,
  data    = df
)

subset_str <- paste0("(", paste(cand, collapse = " + "), ") <= 1")
subset_expr <- parse(text = subset_str)[[1]]

environment(subset_expr) <- environment(formula(mod_count_initial))

args <- list(
  global.model = mod_count_initial,
  fixed        = forced,
  subset       = subset_expr,
  rank         = "AIC",
  cluster      = cl,
  trace        = TRUE
)
dredge_count_2 <- do.call(MuMIn::dredge, args)

# Extraire le meilleur modèle count
best_count_2 <- get.models(dredge_count_2, 1)[[1]]
message("Formule count sélectionnée : ")
print(formula(best_count_2))
```

```{r dernier_select_fiable, eval = FALSE}
# Iterative sélection de modèles pour glmmTMB (count et zero)

# 0. Charger les packages
library(glmmTMB)
library(MuMIn)
library(parallel)

zinbm_df <- longitudinal_strain_host

zinbm_df <- na.omit(zinbm_df)

#On ajoute les densités scalées
zinbm_df$log.dens.self <- scale(zinbm_df$log.dens.self)
zinbm_df$log.density <- scale(zinbm_df$log.density)
zinbm_df$age <- scale(zinbm_df$age)
zinbm_df$poids <- scale(zinbm_df$poids)
zinbm_df$taille_cm <- scale(zinbm_df$taille_cm)
zinbm_df$nombre_foyer <- scale(zinbm_df$nombre_foyer)

zinbm_df$mlva <- NULL
zinbm_df$id.clone <- NULL
zinbm_df$residency <- NULL
zinbm_df$residency_scaled_groups <- NULL
zinbm_df$residency_scaled_log_groups <- NULL
zinbm_df$resident_status <- NULL
zinbm_df$date_min <- NULL
zinbm_df$date_max <- NULL
zinbm_df$dates_samples <- NULL
zinbm_df$time_since_start <- NULL
zinbm_df$time_max <- NULL

zinbm_df$age_group <- NULL
zinbm_df$precarity_group <- NULL
zinbm_df$foyer_group <- NULL

zinbm_df$density <- NULL
zinbm_df$dens.self <- NULL
zinbm_df$code_postal <- NULL
zinbm_df$pays_de_naissance <- NULL

#Pour ZI model : 
zinbm_df$nombre_enfants <- NULL
zinbm_df$sport_group <- NULL
zinbm_df$ville_group <- NULL

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(zinbm_df$group, zinbm_df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
zinbm_df$group_new <- as.character(zinbm_df$group)
zinbm_df$group_new[zinbm_df$group_new %in% rare_levels] <- "other"
zinbm_df$group_new <- factor(zinbm_df$group_new)

#Pour la convergence et le calcul des pvalue
zinbm_df$group <- NULL

# 0. Charger les packages
library(glmmTMB)   # pour glmmTMB()
library(MuMIn)     # pour dredge()
library(parallel)  # pour makeCluster()

# 1. Préparation
df      <- zinbm_df
resp    <- "number_event"
forced  <- c("log.density", "log.dens.self", "group_new")
allVars <- setdiff(names(df), c(resp, "host"))
cand    <- setdiff(allVars, forced)

# 2. Initialisation
# Zi intercept-only + random effect
zi_terms    <- "1"
count_terms <- NULL

# Formules de départ
count_form <- as.formula(
  paste0(resp, " ~ ", paste(c(forced, cand), collapse = " + "), " + (1|", host, ")")
)
zi_form <- as.formula(
  paste0("~ ", zi_terms, " + (1|", host, ")")
)

# 3. Initialisation du cluster
cl <- makeCluster(6)
clusterEvalQ(cl, {
  library(glmmTMB)
  library(MuMIn)
})
options(na.action = "na.fail")

# 4. Boucle itérative
converged <- FALSE
iteration <- 1
while(!converged) {
  message("Itération ", iteration)

  # 4a. Dredge sur la partie count (ZI fixé)
  mod_count_full <- glmmTMB(
    formula = count_form,
    zi      = zi_form,
    family  = nbinom2,
    data    = df
  )
  dredge_count <- dredge(
    mod_count_full,
    fixed   = forced,
    rank    = "AIC",
    cluster = cl
  )
  best_count <- get.models(dredge_count, 1)[[1]]

  # Extraire les termes retenus pour count
  new_count_terms <- attr(terms(formula(best_count)), "term.labels")

  # 4b. Dredge sur la partie zero (Count fixé)
  mod_zi_full <- glmmTMB(
    formula = formula(best_count),
    zi      = zi_form,  # on remplacera ci-dessous
    family  = nbinom2,
    data    = df
  )
  # Mettre à jour formules zi avec toutes les variables candidates
  zi_full <- as.formula(
    paste0("~ ", paste(c(forced, cand), collapse = " + "), " + (1|", host, ")")
  )
  dredge_zi <- dredge(
    update(mod_zi_full, zi = zi_full),
    fixed   = forced,
    rank    = "AIC",
    cluster = cl
  )
  best_zi <- get.models(dredge_zi, 1)[[1]]

  # Extraire les termes retenus pour zi
  new_zi_terms <- attr(terms(ziformula(best_zi)), "term.labels")

  # 4c. Vérifier convergence
  if (!is.null(count_terms) && !is.null(zi_terms)) {
    if (setequal(new_count_terms, count_terms) && setequal(new_zi_terms, zi_terms)) {
      converged <- TRUE
      break
    }
  }

  # 4d. Mettre à jour pour l'itération suivante
  count_terms <- new_count_terms
  zi_terms    <- new_zi_terms

  count_form <- formula(best_count)
  zi_form    <- ziformula(best_zi)

  iteration <- iteration + 1
}

# 5. Arrêter le cluster
stopCluster(cl)

# 6. Résumé du modèle final
message("Modèle final (count) :")
print(formula(best_count))
message("Modèle final (zero) :")
print(ziformula(best_zi))
summary(best_zi)
```

```{r pitie_2, eval = FALSE}
# ========================================
# Sélection manuelle parallélisée ZI-glmmTMB
# Avec combinaisons de 1 à 5 candidats (forcées + up to 5)
# Utilise 6 cœurs sur 8 disponibles
# ========================================

# 0. Charger les packages
library(glmmTMB)
library(dplyr)
library(parallel)

# 1. Préparer les données
# (adaptez à votre dataframe réelle)
df <- longitudinal_strain_host %>%
  na.omit() %>%
  mutate(
    host           = as.factor(host),    # s'assurer que host est un facteur
    log.dens.self  = scale(log.dens.self),
    log.density    = scale(log.density),
    age            = scale(age),
    poids          = scale(poids),
    taille_cm      = scale(taille_cm),
    nombre_foyer   = scale(nombre_foyer)
  ) %>%
  dplyr::select(-c(
    mlva, id.clone, residency, residency_scaled_groups,
    residency_scaled_log_groups, resident_status,
    date_min, date_max, dates_samples,
    time_since_start, time_max,
    age_group, precarity_group, foyer_group,
    density, dens.self, code_postal, pays_de_naissance,
    nombre_enfants, sport_group, ville_group
  ))

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(df$group, df$sex)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
df$group <- as.character(df$group)
df$group[df$group %in% rare_levels] <- "other"
df$group <- factor(df$group)

# Calcul du nombre d'observations pour chaque combinaison group x sex
counts <- table(df$group, df$voie_accouchement)
# Identification des niveaux ayant moins de 2 observations dans AU MOINS UNE des catégories de sex
rare_levels <- rownames(counts)[apply(counts, 1, function(x) any(x <= 2))]
# Création de la nouvelle variable group_new en remplaçant les niveaux rares par "other"
df$group <- as.character(df$group)
df$group[df$group %in% rare_levels] <- "other"
df$group <- factor(df$group)

# 2. Définir réponse, variables forcées et termes candidats
resp    <- "number_event"
forced  <- c("log.density", "log.dens.self", "group")
# extraire tous les termes de la formule incluant fixed et random
all_terms <- attr(terms(
  as.formula(paste0(resp, " ~ . + (1|host)")), data = df
), "term.labels")
# retirer forcées, 'host' et tout terme contenant '|' (random)
cand    <- setdiff(all_terms, c(forced, "host", "1 | host"))

# Formules de base
base_count_formula <- as.formula(
  paste0(resp, " ~ ", paste(forced, collapse = " + "), " + (1|host)")
)
zi_base <- ~ 1 + (1|host)

# 3. Générer toutes les combinaisons de 1 à 5 variables candidates
combo_list <- unlist(
  lapply(1:5, function(k) combn(cand, k, simplify = FALSE)),
  recursive = FALSE
)

# 4. Initialiser le cluster
ncores <- 6
cl <- makeCluster(ncores)
clusterEvalQ(cl, { library(glmmTMB); library(dplyr) })
clusterExport(cl, c("df", "resp", "forced", "zi_base", "combo_list"), envir = environment())

# 5. Boucle parallèle pour la partie COUNT
res_count_list <- parLapply(cl, combo_list, function(vars) {
  combo_name <- paste(vars, collapse = " + ")
  f <- as.formula(
    paste0(resp, " ~ ", paste(c(forced, vars), collapse = " + "), " + (1|host)")
  )
  aic <- tryCatch({
    m <- glmmTMB(formula = f, zi = zi_base, family = nbinom2, data = df)
    AIC(m)
  }, error = function(e) NA)
  list(combo = combo_name, AIC = aic)
})

# Ajouter le modèle vide
base_aic <- tryCatch({
  AIC(
    glmmTMB(formula = base_count_formula, zi = zi_base, family = nbinom2, data = df)
  )
}, error = function(e) NA)
res_count <- bind_rows(
  tibble(combo = "(none)", AIC = base_aic),
  bind_rows(lapply(res_count_list, as_tibble))
)

# 6. Calculer ΔAIC et poids
res_count <- res_count %>%
  filter(!is.na(AIC)) %>%
  arrange(AIC) %>%
  mutate(
    delta  = AIC - min(AIC),
    weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta))
  )

# Afficher tableau count
cat("=== Sélection COUNT (forcées + 1-5 candidats) ===\n")
print(res_count)

# 7. Meilleure combinaison count
best_count_combo <- res_count$combo[1]
message("Count : meilleure combo → ", best_count_combo)

# 8. Préparer la formule count retenue
tfm_count <- if (best_count_combo == "(none)") {
  base_count_formula
} else {
  vars <- strsplit(best_count_combo, " \\+ ")[[1]]
  as.formula(
    paste0(resp, " ~ ", paste(c(forced, vars), collapse = " + "), " + (1|host)")
  )
}

# 9. Boucle parallèle pour la partie ZERO-INFLATION
res_zi_list <- parLapply(cl, combo_list, function(vars) {
  combo_name <- paste(vars, collapse = " + ")
  zf <- as.formula(
    paste0(resp, " ~ ", paste(c(forced, vars), collapse = " + "), " + (1|host)")
  )
  aic <- tryCatch({
    m_zi <- glmmTMB(formula = tfm_count, zi = zf, family = nbinom2, data = df)
    AIC(m_zi)
  }, error = function(e) NA)
  list(combo = combo_name, AIC = aic)
})

# Ajouter le modèle vide en ZI
base_zi_aic <- tryCatch({
  AIC(
    glmmTMB(formula = tfm_count, zi = zi_base, family = nbinom2, data = df)
  )
}, error = function(e) NA)
res_zi <- bind_rows(
  tibble(combo = "(none)", AIC = base_zi_aic),
  bind_rows(lapply(res_zi_list, as_tibble))
)

# 10. ΔAIC et poids pour ZI
res_zi <- res_zi %>%
  filter(!is.na(AIC)) %>%
  arrange(AIC) %>%
  mutate(
    delta  = AIC - min(AIC),
    weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta))
  )

# Afficher tableau ZI
cat("\n=== Sélection ZERO-INFLATION (forcées + 1-5 candidats) ===\n")
print(res_zi)

# 11. Meilleure combo ZI
best_zi_combo <- res_zi$combo[1]
message("ZI : meilleure combo → ", best_zi_combo)

# 12. Ajuster le modèle final et afficher résumé + random effect
chosen_zi <- if (best_zi_combo == "(none)") {
  zi_base
} else {
  vars <- strsplit(best_zi_combo, " \\+ ")[[1]]
  as.formula(
    paste0("~ ", paste(c(forced, vars), collapse = " + "), " + (1|host)")
  )
}

best_model <- glmmTMB(
  formula = tfm_count,
  zi      = chosen_zi,
  family  = nbinom2,
  data    = df
)

cat("\n=== Résumé du modèle final ===\n")
print(summary(best_model))

cat("\n=== Variance de l'aléatoire (1|host) ===\n")
print(VarCorr(best_model))

# 13. Arrêter le cluster
stopCluster(cl)
```

## Colonisation et facteurs hôtes 

On a vu dans les parties précédentes que les temps de résidences des souches résidentes pouvaient être expliqués par différents facteurs hôtes et bactériens. On va poursuivre cette voie en calculant le turnover des souches résidentes c'est à dire la colonisation des souches. Deux façons : global (la moyenne pour un hôte) et focale (temps différents pour toutes les souches).

```{r colonisation}
# Temps de colonisation moyen par hôtes : On ne peut pas calculer directement un temps de colonisation pour les premières valeurs à gauche mais on va s'en servir comme référence.

# 1. Extraire les événements uniques de colonisation pour chaque host (en excluant time_since_start == 0)
colonisations_uniques <- longitudinal_strain_host %>%
  filter(time_since_start != 0) %>%             # Ne garder que les colonisations
  group_by(host, time_since_start) %>%          # Regrouper par host et par temps
  slice(1) %>%                                  # Conserver la première occurrence pour chaque groupe
  ungroup() %>%
  arrange(host, time_since_start) %>%           # Ordonner les événements par host et temps
  group_by(host) %>%
  mutate(temps_colonisation = time_since_start - lag(time_since_start, default = 0)) %>%  # Calculer le temps entre colonisations
  ungroup()

# 2. Rejoindre la nouvelle information dans le dataframe original
longitudinal_strain_host <- longitudinal_strain_host %>%
  left_join(
    colonisations_uniques %>% 
      dplyr::select(host, time_since_start, temps_colonisation),
    by = c("host", "time_since_start")
  ) %>%
  # Pour les lignes où time_since_start == 0, forcer temps_colonisation à NA
  mutate(temps_colonisation = if_else(time_since_start == 0, as.numeric(NA), temps_colonisation))

# Problème : actuellement temps de colonisation est dépendant des dates de sampling. Si on sample pas toutes les deux semaines ça biaise (peut etre qu'on pourrait recentrer tous les temps en fonction du nombre de jours entre les samplings). Voir si c'est grave
# Pour le résoudre pour l'instant j'enlève à la main les temps de colonisation du à un mauvais sampling. Par exemple ces deux points abberants.

to_exclude <- c(71, 127)

#longitudinal_strain_host <- longitudinal_strain_host[longitudinal_strain_host$temps_colonisation != 71,]

#longitudinal_strain_host <- longitudinal_strain_host[longitudinal_strain_host$temps_colonisation != 127,]
```

`temps_colonisation` contient l'intervalle entre deux évènements de colonisation pour chaque souche où il est possible d'en calculer un. A partir de ces temps on calcule `temps_colonisation_mean` qui est le temps moyen chez un hôte. C'est ceci qu'on va expliquer avec les facteurs hôtes.

### Facteurs hôtes et temps de colonisation moyen

```{r colo_mean_lm}
# Agrégation du jeu de données longitudinal_strain_host pour obtenir une seule ligne par host
longitudinal_strain_agg <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    temps_colonisation_mean = mean(temps_colonisation, na.rm = TRUE),
    # Ici, nous prenons la première valeur pour voyage_event et prise_antibiotique 
    # Vous pouvez adapter selon vos besoins (ex: mode, ou une autre règle)
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  )

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_colonisation <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_colonisation <- lm_df_colonisation %>%
  left_join(longitudinal_strain_agg, by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, nombre_foyer, voie_accouchement, sport_frequence), as.factor))

#On crée une colonne dates moyennes de sampling pour essayer de décorréler voyage event du biais de sampling
resultats <- longitudinal %>%
  # On regroupe par hôte
  group_by(host) %>%
  # On extrait les dates uniques pour chaque hôte
  distinct(date, .keep_all = TRUE) %>%
  # On trie les dates pour être sûr que le calcul des différences se fasse correctement
  arrange(date) %>%
  # On calcule la différence entre chaque date consécutive (en jours ici, vous pouvez adapter l'unité)
  mutate(diff_jours = as.numeric(difftime(date, lag(date), units = "days"))) %>%
  # On fait la moyenne sur les différences (en ignorant le NA qui apparaît pour la première date)
  summarise(temps_moyen_samples = mean(diff_jours, na.rm = TRUE)) %>%
  ungroup()

lm_df_colonisation <- left_join(
    lm_df_colonisation, resultats, by = c("record_id" = "host"))

lm_df_colonisation$record_id <- NULL
lm_df_colonisation$code_postal <- NULL
lm_df_colonisation$pays_de_naissance <- NULL
lm_df_colonisation$sport_group <- NULL
lm_df_colonisation$age_group <- NULL
lm_df_colonisation$precarity_group <- NULL
lm_df_colonisation$foyer_group <- NULL

lm_df_colonisation$perturbation_event <- lm_df_colonisation$voyage_event | lm_df_colonisation$prise_antibiotique

lm_df_colonisation$prise_antibiotique <- NULL
lm_df_colonisation$voyage_event <- NULL

#lm_df_colonisation$sport_frequence <- NULL
#lm_df_colonisation$temps_moyen_samples <- NULL

#lm_df_colonisation <- lm_df_colonisation[lm_df_colonisation$temps_colonisation_mean<100,]
lm_df_colonisation <- na.omit(lm_df_colonisation)

lm_df_colonisation$nombre_foyer <- as.numeric(lm_df_colonisation$nombre_foyer)

lm_df_colonisation$age = scale(lm_df_colonisation$age)
lm_df_colonisation$taille_cm = scale(lm_df_colonisation$taille_cm)
lm_df_colonisation$poids = scale(lm_df_colonisation$poids)
lm_df_colonisation$score_epices = scale(lm_df_colonisation$score_epices)
lm_df_colonisation$temps_colonisation_mean = scale(lm_df_colonisation$temps_colonisation_mean)
lm_df_colonisation$temps_moyen_samples = scale(lm_df_colonisation$temps_moyen_samples)

#mod_full <- lm(log(temps_colonisation_mean + 1) ~ . , data = lm_df_colonisation)
#summary(mod_full)
#stepAIC(mod_full, direction = "both")

# Meilleur modèle : On va lui enlever les variables non significatives pour réduire l'overfitting
best_mod_colonisation <- lm(formula = log(temps_colonisation_mean + 1) ~ sex + voie_accouchement + 
    allaitement + nombre_foyer + temps_moyen_samples, data = lm_df_colonisation)
summary(best_mod_colonisation)
Anova(best_mod_colonisation)

# On teste une regression LASSO
#library(glmnet)
# Création des matrices pour glmnet
#X <- as.matrix(dplyr::select(lm_df_colonisation, - temps_colonisation_mean))
#y <- lm_df_colonisation$temps_colonisation_mean
# LASSO avec validation croisée
#cv_lasso <- cv.glmnet(X, y, alpha = 1)
# Lambda optimal
#best_lambda <- cv_lasso$lambda.min
# Modèle final
#lasso_model <- glmnet(X, y, alpha = 1, lambda = best_lambda)
# Coefficients sélectionnés
#coef(cv_lasso)
# CCL : LASSO ne retiens aucune variable
```

On a ajouté une variable `temps_moyen_samples` qui regroupent le temps moyen (par hôte) chez deux samples consécutifs. En effet, la façon dont on calcule les temps de colonisation est biaisée par ce temps moyen consécutifs entre les samples. Ainsi, cette variable corrèle évidemment avec le temps moyen de colonisation mais sa présence dans le modèle va permettre d'être sûr que l'effet des autres variables ne vient pas du biais.

Plusieurs modèles ont été établis car une difficulté se pose pour la sélection du meilleur modèle : le surapprentissage. En effet on a 13 variables explicatives en tout et 43 observations. Une régression LASSO a été effectuée mais n'a donnée que des coefficients de variables nuls.

Au final, avec le df présent, nous avons une sélection par comparaison de AIC qui donne comme meilleur modèle : le sexe, la voie d'accouchement, l'allaitement, le nombre de personnes dans le foyer (et le temps moyen de sampling). Ces variables sont significatives sauf le sexe.

Leur sens est : 

- Les femmes ont des temps de colonisation moyen plus longs que les hommes.
- Les personnes nées par césarienne ont des temps de colonisation moyen plus longs que les personnes nées par voie vaginale.
- Les personnes non allaitées par leur mère ont des temps de colonisation moyen plus court que les personnes allaitées par leur mère.
- Plus une personne a d'individus dans son foyer plus son temps de colonisation moyen est court.

Le fait que l'allaitement et la voie d'accouchement soient anticorrélés est un peu surprenant.
 - OLD
 
 
 
## Diversité intrahôte et facteurs hôtes 

### Diversité globale et facteurs hôtes - OLD 

On peut calculer le nombre de souches par hôte en divisant par le temps de la cohorte.
`global_diversity` contient le nombre d'évènements de colonisation (ie le nombre de souches différentes vues) divisé par la durée de sampling. On va l'expliquer avec les facteurs hôtes.

```{r global_col_lm}
# Ajouter les temps moyens entre samples aussi pour la div

# Agrégation du jeu de données longitudinal_strain_host pour obtenir une seule ligne par host
longitudinal_strain_agg <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    global_diversity = n() / max(time_max, na.rm = TRUE),
    # Ici, nous prenons la première valeur pour voyage_event et prise_antibiotique 
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  )

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_diversity <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_diversity <- lm_df_diversity %>%
  left_join(longitudinal_strain_agg, by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, nombre_foyer, voie_accouchement, sport_frequence), as.factor))

lm_df_diversity$record_id <- NULL
lm_df_diversity$code_postal <- NULL
lm_df_diversity$pays_de_naissance <- NULL
lm_df_diversity$sport_group <- NULL
lm_df_diversity$age_group <- NULL
lm_df_diversity$precarity_group <- NULL
lm_df_diversity$foyer_group <- NULL

#lm_df_diversity$perturbation_event <- lm_df_diversity$voyage_event | lm_df_diversity$prise_antibiotique

#lm_df_diversity$prise_antibiotique <- NULL
#lm_df_diversity$voyage_event <- NULL

lm_df_diversity$nombre_foyer <- as.numeric(lm_df_diversity$nombre_foyer)
lm_df_diversity$sport_frequence <- NULL

lm_df_diversity$age = scale(lm_df_diversity$age)
lm_df_diversity$taille_cm = scale(lm_df_diversity$taille_cm)
lm_df_diversity$poids = scale(lm_df_diversity$poids)
lm_df_diversity$score_epices = scale(lm_df_diversity$score_epices)
#lm_df_diversity$global_diversity = scale(lm_df_diversity$global_diversity)

#Selection du meilleur modèle
#mod_full_div <- lm(formula = global_diversity ~ ., data = lm_df_diversity)
#summary(mod_full_div)
#stepAIC(mod_full_div, direction = "both")

#Meilleur modèle par comparaison des AIC
best_lm_diversity <- lm(formula = global_diversity ~ age + poids + voie_accouchement + 
    allaitement, data = lm_df_diversity)
summary(best_lm_diversity)
Anova(best_lm_diversity)
```
Global diversity est le nombre de nouvelles souches par jour.

On sélectionne le modèle par comparaison d'AIC. L'age, le poids, la façon de naître et l'allaitement sont sélectionnés pour le meilleur modèle. L'effet age et allaitement sont significatifs.

D'après les coefficients de la régression : 

- Une personne plus âgées que la moyenne va avoir moins de diversité de souches.
- Les personnes plus lourdes ont plus de diversité de souches.
- Les personnes nées sous césarienne ont moins de diversité par rapport aux personnes nées par voie vaginale.
- Les personnes allaitées par leur mère ont moins de diversité que les personnes allaitées autrement.

### Diversité au cours du temps et facteurs hôtes - OLD 

On peut calculer le nombre de souches différentes en fonction du temps chez chaque hôte.

```{r diversity_time_2, fig.height=20, fig.width=20}
#On crée une colonne dates moyennes de sampling pour essayer de décorréler voyage event du biais de sampling
df_diversity <- longitudinal %>%
  # On regroupe par hôte
  group_by(host, date) %>%
  mutate(diversity = n()) %>%
  dplyr::select(host, diversity) %>%
  distinct(date, .keep_all = TRUE) %>%
  ungroup()

plot_diversity_time <- ggplot(df_diversity, aes(x = date, y = diversity)) + 
    facet_wrap(
    ~host, 
    scales = "free_x", 
    labeller = labeller(host = function(value) paste0("Host ", value))  # Custom labeller for host
  ) +
  geom_line() + 
  geom_point() +
  xlab("Dates") + 
  ylab("Diversité") +
  theme_bw() +
  theme(
    legend.position = "top",  # Move legend to the top
    legend.direction = "horizontal",  # Make legend horizontal
    legend.box = "horizontal",  # Ensure legend items are in a single row
    text = element_text(size = 10),  # General text size
    axis.text = element_text(size = 6),  # Axis text size
    strip.text = element_text(size = 4),  # Facet label text size
    panel.spacing = unit(1, "lines")  # Adjust spacing between facets
  )

plot_diversity_time
```

La diversité fluctue au cours du temps. Globalement elle reste basse et parvient à des pics à quelques moments de sampling. Ceci pourrait correspondre au mode de vie des E. coli commensales du microbiote intestinal humain : la majeure partie du temps il y a une souche résidente qui est majoritaire en terme de densité (et donc on ne capte pratiquement qu'elle en faisant 5 relevés) puis à certaines courtes périodes on observe des transientes en grand nombre ce qui augmente d'un coup la diversité.

Voyons si la diversité moyenne change en fonction si l'hôte a eu un traitement antibiotique, un voyage ou rien.

```{r event_diversity}
df_antibio <- antibiotique %>%
  group_by(record_id) %>%
  summarise(min_date_traitement = min(date_traitement, na.rm = TRUE))
df_antibio$record_id <- as.factor(df_antibio$record_id)
df_diversity <- df_diversity %>%
  left_join(df_antibio, by = c("host" = "record_id")) %>%
  mutate(antibiotique_avant_apres = if_else(min_date_traitement < date, TRUE, FALSE, missing = FALSE))
df_diversity$min_date_traitement <- NULL

df_voyage <- voyage %>%
  group_by(record_id) %>%
  summarise(min_date_voyage = min(date_voyage, na.rm = TRUE))
df_voyage$record_id <- as.factor(df_voyage$record_id)
df_diversity <- df_diversity %>%
  left_join(df_voyage, by = c("host" = "record_id")) %>%
  mutate(voyage_avant_apres = if_else(min_date_voyage < date, TRUE, FALSE, missing = FALSE))
df_diversity$min_date_voyage <- NULL

#df_diversity$event <- df_diversity$antibiotique_avant_apres | df_diversity$voyage_avant_apres

# Diversité moyenne en fonction de si un des evenements
#df_diversity <- df_diversity %>%
#  group_by(host) %>%
#  mutate(mean_diversity = mean(diversity))

df_diversity <- df_diversity %>%
  group_by(host) %>%
  mutate(
    groupe_event = case_when(
      antibiotique_avant_apres == TRUE & voyage_avant_apres == TRUE ~ "Antibio + Voyage",
      antibiotique_avant_apres == TRUE & voyage_avant_apres == FALSE ~ "Antibio seul",
      antibiotique_avant_apres == FALSE & voyage_avant_apres == TRUE ~ "Voyage seul",
      antibiotique_avant_apres == FALSE & voyage_avant_apres == FALSE ~ "Aucun"
    )
  )

df_diversity <- df_diversity %>%
  mutate(groupe_event = factor(groupe_event, levels = c("Aucun", "Antibio seul", "Voyage seul", "Antibio + Voyage")))
  
#Diversité en fonction de si le sampling se fait après un voyage, antibiotique ou les deux ou aucun
plot_diversity_event <- ggplot(df_diversity, aes(x = groupe_event, y = diversity, fill = groupe_event)) +
  geom_violin(trim = FALSE, alpha = 0.4) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.8) +
  stat_summary(fun = mean, geom = "point", shape = 21, size = 3, fill = "white", color = "black") +
  labs(
    title = "Nombre de bactéries samplées selon les évènements",
    x = "Evènement",
    y = "Nombre samplé après l'évènement"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")

plot_diversity_event
```

Faire un voyage semble légèrement augmenter le nombre de bactéries samplées par rapport à ne subir aucun évènement.
En revanche prendre un traitement antibiotique semble baisser le nombre de bactéries samplées après la prise. Faire un voyage après avoir pris un antibiotique semble rééquilibrer la diversité au niveau avant antibiotique (car la moyenne est remonte vers celle du groupe "Aucun"). 

Tout ceci n'a pas l'air très puissant mais les observations vont dans le sens attendu et donc il est intéressant de le noter.

Modèle linéaire mixte de ceci, en prenant donc en compte un effet hôte.

```{r lmm_diversity_event_}
lmm_diversity_event <- lmer(formula = diversity ~ groupe_event + (1 | host), data = df_diversity)

summary(lmm_diversity_event)
```

Rien de significatif mais les coefficients du lmm appuie ce qui a été évoqué plus haut. Plus de données serait nécessaire pour obtenir une significativité.

En considérant des event récent (Tout event de plus de 2 mois avant cohorte est éliminé)

```{r event_recent_diversity}
# On repart d'un df de diversité
df_diversity_recent <- longitudinal %>%
  # On regroupe par hôte
  group_by(host, date) %>%
  mutate(diversity = n()) %>%
  dplyr::select(host, diversity) %>%
  distinct(date, .keep_all = TRUE) %>%
  ungroup()

# Pour les antibios
df_antibio <- antibiotique %>%
  group_by(record_id) %>%
  summarise(dates_traitement = list(date_traitement)) 
df_antibio$record_id <- as.factor(df_antibio$record_id)
df_diversity_recent <- df_diversity_recent %>%
  left_join(df_antibio, by = c("host" = "record_id"))

df_diversity_recent <- df_diversity_recent %>%
  group_by(host) %>%
  mutate(min_date_sample = min(date) - 60)

df_diversity_recent <- df_diversity_recent %>%
  mutate(
    dates_traitement = map2(dates_traitement, min_date_sample, ~ {
      res <- .x[.x > .y]
      if (length(res) == 0) NULL else res
    })
  )

df_diversity_recent <- df_diversity_recent %>%
  mutate(
    antibiotique_avant_apres = map2_lgl(dates_traitement, date, ~ any(.x < .y))
  )

df_diversity_recent$min_date_sample <- NULL
df_diversity_recent$dates_traitement <- NULL

#Pour les voyages
df_voyage <- voyage %>%
  group_by(record_id) %>%
  summarise(dates_voyage = list(date_voyage)) 
df_voyage$record_id <- as.factor(df_voyage$record_id)
df_diversity_recent <- df_diversity_recent %>%
  left_join(df_voyage, by = c("host" = "record_id"))

df_diversity_recent <- df_diversity_recent %>%
  group_by(host) %>%
  mutate(min_date_sample = min(date) - 60)

df_diversity_recent <- df_diversity_recent %>%
  mutate(
    dates_voyage = map2(dates_voyage, min_date_sample, ~ {
      res <- .x[.x > .y]
      if (length(res) == 0) NULL else res
    })
  )

df_diversity_recent <- df_diversity_recent %>%
  mutate(
    voyage_avant_apres = map2_lgl(dates_voyage, date, ~ any(.x < .y))
  )

df_diversity_recent$min_date_sample <- NULL
df_diversity_recent$dates_voyage <- NULL

df_diversity_recent <- df_diversity_recent %>%
  group_by(host) %>%
  mutate(
    groupe_event = case_when(
      antibiotique_avant_apres == TRUE & voyage_avant_apres == TRUE ~ "Antibio + Voyage",
      antibiotique_avant_apres == TRUE & voyage_avant_apres == FALSE ~ "Antibio seul",
      antibiotique_avant_apres == FALSE & voyage_avant_apres == TRUE ~ "Voyage seul",
      antibiotique_avant_apres == FALSE & voyage_avant_apres == FALSE ~ "Aucun"
    )
  )

df_diversity_recent <- df_diversity_recent %>%
  mutate(groupe_event = factor(groupe_event, levels = c("Aucun", "Antibio seul", "Voyage seul", "Antibio + Voyage")))

ggplot(df_diversity_recent, aes(x = groupe_event, y = diversity, fill = groupe_event)) +
  geom_violin(trim = FALSE, alpha = 0.4) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.8) +
  stat_summary(fun = mean, geom = "point", shape = 21, size = 3, fill = "white", color = "black") +
  labs(
    title = "Nombre de bactéries samplées selon les évènements",
    x = "Evènement",
    y = "Nombre samplé après l'évènement"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")

lmm_diversity_event <- lmer(formula = diversity ~ groupe_event + (1 | host), data = df_diversity_recent)

summary(lmm_diversity_event)
```

On a les mêmes résultats en moins puissant car on élimine des cas.

### Diversité moyenne et facteurs hôtes - OLD 

```{r mean_div_lm}
df_mean_diversity <- dplyr::select(df_diversity, host, diversity, groupe_event) %>%
  group_by(host) %>%
  summarise(mean_diversity = mean(diversity),
            groupe_event = last(groupe_event))

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_mean_diversity <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_mean_diversity <- lm_df_mean_diversity %>%
  left_join(df_mean_diversity, by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, nombre_foyer, voie_accouchement, sport_frequence), as.factor))

lm_df_mean_diversity$record_id <- NULL
lm_df_mean_diversity$code_postal <- NULL
lm_df_mean_diversity$pays_de_naissance <- NULL
lm_df_mean_diversity$sport_group <- NULL
lm_df_mean_diversity$age_group <- NULL
lm_df_mean_diversity$precarity_group <- NULL
lm_df_mean_diversity$foyer_group <- NULL
lm_df_mean_diversity$sport_frequence <- NULL

lm_df_mean_diversity$nombre_foyer <- as.numeric(lm_df_mean_diversity$nombre_foyer)

lm_df_mean_diversity$age = scale(lm_df_mean_diversity$age)
lm_df_mean_diversity$taille_cm = scale(lm_df_mean_diversity$taille_cm)
lm_df_mean_diversity$poids = scale(lm_df_mean_diversity$poids)
lm_df_mean_diversity$score_epices = scale(lm_df_mean_diversity$score_epices)

#Selection du meilleur modèle
#mod_full_div <- lm(formula = mean_diversity ~ ., data = lm_df_mean_diversity)
#summary(mod_full_div)
#stepAIC(mod_full_div, direction = "both")

#Meilleur modèle par comparaison des AIC
best_lm_mean_diversity <- lm(formula = mean_diversity ~ age + voie_accouchement + allaitement, 
    data = lm_df_mean_diversity)
summary(best_lm_mean_diversity)
Anova(best_lm_mean_diversity)
```

### Indice de Shannon et facteurs hôtes - OLD 

On calcule un indice de shannon pour chaque sample puis on moyenne par hôte. On obtient ainsi un indicateur de diversité moyenne qu'on va pouvoir essayer de corréler aux facteurs hôtes.

```{r shannon_time, fig.height=20, fig.width=20}
longitudinal_norm <- longitudinal %>%
  group_by(id.sample) %>%
  mutate(prop = dens.self / sum(dens.self)) %>%
  ungroup()

shannon_df <- longitudinal_norm %>%
  group_by(host, date) %>%
  summarise(shannon = diversity(prop, index = "shannon"), .groups = "drop")

plot_shannon_time <- ggplot(shannon_df, aes(x = date, y = shannon)) + 
    facet_wrap(
    ~host, 
    scales = "free_x", 
    labeller = labeller(host = function(value) paste0("Host ", value))  # Custom labeller for host
  ) +
  geom_line() + 
  geom_point() +
  xlab("Dates") + 
  ylab("Diversité") +
  theme_bw() +
  theme(
    legend.position = "top",  # Move legend to the top
    legend.direction = "horizontal",  # Make legend horizontal
    legend.box = "horizontal",  # Ensure legend items are in a single row
    text = element_text(size = 10),  # General text size
    axis.text = element_text(size = 6),  # Axis text size
    strip.text = element_text(size = 4),  # Facet label text size
    panel.spacing = unit(1, "lines")  # Adjust spacing between facets
  )

plot_shannon_time
```

Cette représentation est très proche de la diversité qu'on obtenait tout à l'heure. On va la moyenner et l'expliquer par un lm.


```{r shannon_mean}
# Moyenne de l'indice de Shannon par hôte
shannon_moyenne <- shannon_df %>%
  group_by(host) %>%
  summarise(mean_shannon = mean(shannon, na.rm=T), .groups = "drop")

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_shannon <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

#Ajout du groupe d'évent : 
df_shannon_diversity <- dplyr::select(df_diversity, host, groupe_event) %>%
  group_by(host) %>%
  summarise(groupe_event = last(groupe_event))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_shannon <- lm_df_shannon %>%
  left_join(shannon_moyenne, by = c("record_id" = "host")) %>%
  left_join(df_shannon_diversity, by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence), as.factor))

lm_df_shannon$record_id <- NULL
lm_df_shannon$code_postal <- NULL
lm_df_shannon$pays_de_naissance <- NULL
lm_df_shannon$sport_group <- NULL
lm_df_shannon$age_group <- NULL
lm_df_shannon$precarity_group <- NULL
lm_df_shannon$foyer_group <- NULL
lm_df_shannon$sport_frequence <- NULL

lm_df_shannon$age = scale(lm_df_shannon$age)
lm_df_shannon$taille_cm = scale(lm_df_shannon$taille_cm)
lm_df_shannon$poids = scale(lm_df_shannon$poids)
lm_df_shannon$score_epices = scale(lm_df_shannon$score_epices)

#Selection du meilleur modèle
#mod_full <- lm(formula = mean_shannon ~ ., data = lm_df_shannon)
#summary(mod_full)
#stepAIC(mod_full, direction = "both")

#Meilleur modèle par comparaison des AIC
best_lm_shannon <- lm(formula = mean_shannon ~ age + voie_accouchement + allaitement, 
    data = lm_df_shannon)
summary(best_lm_shannon)
Anova(best_lm_shannon)
```

Même résultats qu'avant pour la diversité moyenne.

### Diversité au niveau phylogroupe et facteurs hôtes - OLD 

On va calculer le nombre de phylogroupes différents portés par un hôte pendant la cohorte et expliquer ceci par les facteurs hôtes.

```{r phylogroup_diversity}
# Agrégation du jeu de données longitudinal_strain_host pour obtenir une seule ligne par host
longitudinal_strain_agg <- longitudinal_strain_host %>%
  group_by(host) %>%
  summarise(
    phylogroup_diversity = n_distinct(group) / max(time_max, na.rm = TRUE),
    # Ici, nous prenons la première valeur pour voyage_event et prise_antibiotique 
    voyage_event = first(voyage_event),
    prise_antibiotique = first(prise_antibiotique),
    .groups = "drop"
  )

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_phylo_div <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_phylo_div <- lm_df_phylo_div %>%
  left_join(longitudinal_strain_agg, by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence), as.factor))

lm_df_phylo_div <- lm_df_phylo_div %>%
  mutate(
    groupe_event = case_when(
      prise_antibiotique == TRUE & voyage_event == TRUE ~ "Antibio + Voyage",
      prise_antibiotique == TRUE & voyage_event == FALSE ~ "Antibio seul",
      prise_antibiotique == FALSE & voyage_event == TRUE ~ "Voyage seul",
      prise_antibiotique == FALSE & voyage_event == FALSE ~ "Aucun"
    )
  )

lm_df_phylo_div <- lm_df_phylo_div %>%
  mutate(groupe_event = factor(groupe_event, levels = c("Aucun", "Antibio seul", "Voyage seul", "Antibio + Voyage")))

lm_df_phylo_div$prise_antibiotique <- NULL
lm_df_phylo_div$voyage_event <- NULL

lm_df_phylo_div$record_id <- NULL
lm_df_phylo_div$code_postal <- NULL
lm_df_phylo_div$pays_de_naissance <- NULL
lm_df_phylo_div$sport_group <- NULL
lm_df_phylo_div$age_group <- NULL
lm_df_phylo_div$precarity_group <- NULL
lm_df_phylo_div$foyer_group <- NULL

lm_df_phylo_div$nombre_foyer <- as.numeric(lm_df_phylo_div$nombre_foyer)

lm_df_phylo_div$sport_frequence <- NULL

lm_df_phylo_div$age = scale(lm_df_phylo_div$age)
lm_df_phylo_div$taille_cm = scale(lm_df_phylo_div$taille_cm)
lm_df_phylo_div$poids = scale(lm_df_phylo_div$poids)
lm_df_phylo_div$score_epices = scale(lm_df_phylo_div$score_epices)

lm_df_phylo_div <- na.omit(lm_df_phylo_div)

#Selection du meilleur modèle
#mod_full_div <- lm(formula = phylogroup_diversity ~ ., data = lm_df_phylo_div)
#summary(mod_full_div)
#stepAIC(mod_full_div, direction = "both")

#Meilleur modèle par comparaison des AIC
best_lm_phylo_diversity <- lm(formula = phylogroup_diversity ~ sex + regime + groupe_event, 
    data = lm_df_phylo_div)
summary(best_lm_phylo_diversity)
Anova(best_lm_phylo_diversity)
```

Le meilleur modèle sélectionne le sexe, le régime et les évènements voyage et prise antibiotique. L'effet du régime est significatif. 
Le sens est le suivant : 

- Les femmes auraient moins de diversité moyenne au niveau du phylogroupe que les hommes (pvalue presque significative).
- Les hôtes au régime équilibré auraient moins de diversité que ceux ayant un régime fort en alcool (mais pvalue absolument pas significative).
- Les hôtes avec un régime haut en fibre auraient plus de diversité que ceux avec un régime fort en alcool (pvalue presque significative).
- Les hôtes ayant fait un voyage auraient moins de diversité au niveau phylogroupe.

### Beta-diversité chez un hôte et facteurs hôtes - OLD 

On va voir la dissimilarité entre les samples consécutif chez un même hôte. Ceci est une mesure du renouvellement du microbiote des hôtes. 

On peut ansi comparer les beta diversité entre les hôtes.

```{r betadiv, fig.width=20}
# Étape 1 : préparation des données
longitudinal_norm <- longitudinal %>%
  group_by(id.sample) %>%
  mutate(rel_abundance = dens.self / sum(dens.self)) %>%
  ungroup()

# Pivot wider avec les abondances relatives
wide <- longitudinal_norm %>%
  dplyr::select(host, id.sample, date, id.clone, rel_abundance) %>%
  pivot_wider(
    names_from = id.clone,
    values_from = rel_abundance,
    values_fill = 0
  )

# Calcul BC pondérée entre samples consécutifs
bc_weighted <- wide %>%
  arrange(host, date) %>% #Tri par hote puis par data
  group_by(host) %>% #Groupement par hote
  group_split() %>% #On sépare les dataframe en sous df qu'on peut utiliser dans la boucle suivante
  map_dfr( function(df_host) {
    if (nrow(df_host) < 2) return(NULL)
    abund <- df_host %>% dplyr::select(-host, -id.sample, -date)
    abund[is.na(abund)] <- 0
    bc <- vegdist(abund, method = "bray")
    bc_mat <- as.matrix(bc)
    
    map_dfr(1:(nrow(df_host)-1), function(i) {
      tibble(
        host = df_host$host[i],
        sample_1 = df_host$id.sample[i],
        date_1 = df_host$date[i],
        sample_2 = df_host$id.sample[i+1],
        date_2 = df_host$date[i+1],
        bray_curtis = bc_mat[i, i+1]
      )
    })
  })

plot_mean_bc <- ggplot(bc_weighted, aes(x = host, y = bray_curtis)) +
    geom_point(aes(x = host), size = 1) +  # Points individuels
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +  # Moyenne en rouge
    theme(legend.position = "none") + 
    ggtitle("Moyenne de la Bray-Curtis distance par hôte")

plot_mean_bc
```

BC = 0--> identique

On voit que les BC varient en fonction des hôtes. Certains ont en moyenne des BC plus faibles que d'autres indiquant une variabilité dans le renouvellement des souches chez chaque hôtes.

Les moyennes sont élevées (contrairement à celles dans le papier de Martinson). Ceci pourrait provenir du fait qu'on a plus de diversité en France et donc entre les samples on change beaucoup plus qu'aux US.

Si on moyenne les BC distance on peut l'expliquer avec des facteurs hôtes. 

```{r lm_betadiv}
#On garde que la moyenne des BC par hote
bc_mean <- bc_weighted %>%
  group_by(host) %>%
  summarise(mean_bray_curtis = mean(bray_curtis))

# Préparation du DF metadata en retirant certaines colonnes et en supprimant les NA
lm_df_bc <- metadata %>%
  dplyr::select(-c(11:42)) %>%
  mutate(record_id = as.character(record_id))

# Jointure avec les données agrégées pour garder une seule ligne par host
lm_df_bc <- lm_df_bc %>%
  left_join(bc_mean, by = c("record_id" = "host")) %>%
  left_join(dplyr::select(df_mean_diversity, host, groupe_event), by = c("record_id" = "host")) %>%
  distinct() %>%
  mutate(across(c(sex, pays_de_naissance, allaitement, voie_accouchement, sport_frequence), as.factor))

lm_df_bc$record_id <- NULL
lm_df_bc$code_postal <- NULL
lm_df_bc$pays_de_naissance <- NULL
lm_df_bc$sport_group <- NULL
lm_df_bc$age_group <- NULL
lm_df_bc$precarity_group <- NULL
lm_df_bc$foyer_group <- NULL

lm_df_bc$nombre_foyer <- as.numeric(lm_df_bc$nombre_foyer)

lm_df_bc$sport_frequence <- NULL

lm_df_bc$age = scale(lm_df_bc$age)
lm_df_bc$taille_cm = scale(lm_df_bc$taille_cm)
lm_df_bc$poids = scale(lm_df_bc$poids)
lm_df_bc$score_epices = scale(lm_df_bc$score_epices)

lm_df_bc <- na.omit(lm_df_bc)

#Selection du meilleur modèle
#mod_full_div <- lm(formula = mean_bray_curtis ~ ., data = lm_df_bc)
#summary(mod_full_div)
#stepAIC(mod_full_div, direction = "both")

#Meilleur modèle par comparaison des AIC
best_lm_bc <- lm(formula = mean_bray_curtis ~ sex + age + poids + voie_accouchement + 
    allaitement + groupe_event, data = lm_df_bc)
summary(best_lm_bc)
Anova(best_lm_bc)
```

Les différences entre les BC en moyenne sont expliquées (dans le meilleur modèle) par le sexe (significatif), l'age, le poids, la voie d'accouchement, l'allaitement (significatif) et les évènements antibio/voyage (significatif).

Leur sens  : 

- Les femmes ont une distance de BC moyenne plus faible que les hommes (les femmes ont moins de renouvellement des E. coli, va dans le sens d'une plus longue persistance des souches et de la présence de certains phylogroupes résidents). 
- Plus une personne est vieille moins elle a de distance BC (ie plus on vieillit moins on a de renouvellement du microbiote au niveau des E. coli).
- Une personne non allaitée par sa mère à plus de turnover qu'une personne allaitée.
- Les personnes ayant consommées des antibiotiques ont une distance de BC moyenne plus faibles que ceux n'en ayant pas consommé. Ceci est étonnant : trace de résistance ? de sélection par les antibiotiques de souches résidentes ? hypothèse : les antibiotiques détruisent la diversité des E. coli et ne gardent que les souches résistantes qui dcp ne changent pas entre les samples et ceci baisse la moyenne de la distance BC.

On peut aussi faire la dissimilarité entre toutes les paires de samples et voir si plus les samples sont loin plus la BC augmente.

```{r betadiv_time_plot, fig.height=45, fig.width=10}
bc_weighted_all <- wide %>%
  arrange(host, date) %>%        # Tri par hôte puis par date
  group_by(host) %>%             # Groupement par hôte
  group_split() %>%              # Séparation en sous-dataframes par hôte
  map_dfr(function(df_host) {
    if(nrow(df_host) < 2) return(NULL)   # Si un hôte a moins de 2 échantillons, on ne fait rien
    abund <- df_host %>% dplyr::select(-host, -id.sample, -date)  # Sélection des colonnes d'abondances
    abund[is.na(abund)] <- 0                                    # Remplacement des NA par 0
    bc <- vegdist(abund, method = "bray")                       # Calcul de la distance de Bray-Curtis
    bc_mat <- as.matrix(bc)                                     # Transformation en matrice
    
    # Boucle sur toutes les combinaisons de paires d'échantillons (i, j)
    map_dfr(1:(nrow(df_host) - 1), function(i) {
      map_dfr((i + 1):nrow(df_host), function(j) {
        tibble(
          host = df_host$host[i],
          sample_1 = df_host$id.sample[i],
          date_1 = df_host$date[i],
          sample_2 = df_host$id.sample[j],
          date_2 = df_host$date[j],
          bray_curtis = bc_mat[i, j]
        )
      })
    })
  })

bc_weighted_all <- bc_weighted_all %>%
  mutate(temps_entre_sample = abs(date_1 -date_2))

bc_weighted_all <- bc_weighted_all %>%
  mutate(time_bin = cut(as.numeric(temps_entre_sample), breaks = 10))

cor_data <- bc_weighted_all %>%
  group_by(host) %>%
  summarise(rho = round(cor(as.numeric(temps_entre_sample), bray_curtis, method = "spearman"), 2)) %>%
  ungroup()

# Création du graphique avec boxplots par facette et ajout de l'annotation du coefficient en bas à droite
plot_bc_time <- ggplot(bc_weighted_all, aes(x = time_bin, y = bray_curtis)) + 
  facet_grid(
    rows = vars(host), 
    scales = "free_x", 
    space = "free_x", 
    labeller = labeller(host = function(value) paste0("Host ", value))
  ) +
  xlab("Time") + 
  geom_boxplot() + 
  ylab("Bray Curtis Distance") +
  theme_bw() +
  geom_text(
    data = cor_data,
    mapping = aes(x = Inf, y = -Inf, label = paste("rho =", rho)),
    hjust = 1.1,   # Ajustement pour décaler légèrement vers l'intérieur de la facette
    vjust = -0.1,  # Ajustement pour décaler légèrement vers le haut
    size = 3
  )

plot_bc_time
```


## Résultats au propre pour colonisation et facteurs hôtes

## Diveristé et facteurs hôtes

Il existe plusieurs manières de caractériser la diversité du microbiote dans une cohorte longitudinale.

### Diversité globale pendant la cohorte et facteurs hôtes

On peut utiliser le nombre d'évènements de colonisation divisé par le temps qu'a pris la cohorte afin de caractériser la diversité intrahôte et donc les facteurs hôtes qui peuvent l'affecter. On a donc le nombre de nouvelles souches par jour qu'on explique avec nos facteurs hôtes.

```{r lm_diversity}
summary(best_lm_diversity)
Anova(best_lm_diversity)
```

On sélectionne le modèle par comparaison d'AIC. L'age, le poids, la façon de naître et l'allaitement sont sélectionnés pour le meilleur modèle. L'effet age et allaitement sont significatifs.

D'après les coefficients de la régression : 

- Une personne plus âgées que la moyenne va avoir moins de diversité de souches.
- Les personnes plus lourdes ont plus de diversité de souches.
- Les personnes nées sous césarienne ont moins de diversité par rapport aux personnes nées par voie vaginale.
- Les personnes allaitées par leur mère ont moins de diversité que les personnes allaitées autrement.

### Diversité en fonction du temps et facteurs hôtes

Représentons l'évolution de la diversité des souches chez un hôte. Comme on ne capte que maximum 5 souches par samples on a enfaîte la diversité des souches majoritaires dans l'intestin. Les estimations sont donc assez biaisées mais permettent d'établir une première approche.

```{r diversity_time, fig.height=20, fig.width=20}
plot_diversity_time
```
La diversité fluctue au cours du temps. Globalement elle reste basse et parvient à des pics à quelques moments de sampling. Ceci pourrait correspondre au mode de vie des E. coli commensales du microbiote intestinal humain : la majeure partie du temps il y a une souche résidente qui est majoritaire en terme de densité (et donc on ne capte pratiquement qu'elle en faisant 5 relevés) puis à certaines courtes périodes on observe des transientes en grand nombre ce qui augmente d'un coup la diversité.

On peut s'intéresser à l'effet des antibiotiques ou des voyages sur la diversité. Plus particulièrement nous allons représenter le nombre de bactéries (entre 1 et 5) samplées après un voyage, de prise d'antibiotique, des deux ou bien de rien. 

```{r diversity_event}
plot_diversity_event
```

Faire un voyage semble légèrement augmenter le nombre de bactéries samplées par rapport à ne subir aucun évènement.

En revanche, prendre un traitement antibiotique semble baisser le nombre de bactéries samplées après la prise. Faire un voyage après (ou avant) avoir pris un antibiotique semble rééquilibrer la diversité au niveau avant (ou après) antibiotique (car la moyenne remonte vers celle du groupe "Aucun"). 

Tout ceci n'a pas l'air très puissant mais les observations vont dans le sens attendu et donc il est intéressant de le noter. En revanche cette approche gomme l'effet hôte. 

Un lmm avec effet aléatoire hôte et explication de la diversité par le type d'évènement donne les mêmes résultats :

```{r lmm_diversity_event}
summary(lmm_diversity_event)
```

Effectivement les effets ne sont pas très fort, dans ce cas je pense qu'il s'agit vraiment d'un manque de puissance. 

Jusque là on a considéré les voyages et prise d'antibiotique de la visite d'inclusion mais ceux ci peuvent dater de beaucoup. On va faire la même analyse en considérant que si le traitement/voyage a eu lieu plus de 2 mois avant le premier sample, alors il n'y en a pas eu.
Les résultats sont les mêmes, en un peu moins puissant encore.

On va maintenant, à la façon de la diversité globale, voir les facteurs hôtes qui affectent la diversité moyenne des samples.

### Diversité moyenne des samples et facteurs hôtes

Enfaite cette approche est similaire à la première mais en divisant le nombre total de souches différentes par le nombre de samples et pas le temps total. Petite différence : on recompte ici les souches résidentes à chaque fois. Ainsi la première était plutôt la diversité totale sans prendre en compte le temps. Dans notre cas on moyenne la diversité à chaque pas de temps. 

On va effectuer des modèles linéaires et sélectionner le meilleur par comparaison d'AIC.

```{r mean_diversity}
summary(best_lm_mean_diversity)
Anova(best_lm_mean_diversity)
```

Le meilleur modèle sélectionne l'âge, l'allaitement et la voie d'accouchement. Tous trois sont significatifs au niveau des effets. Ce résultat est cohérent avec celui observé, d'autant plus que le sens des effets est le même que précédemment. 
Nous avons aussi utilisé l'indice de Shannon moyenner sur la cohorte pour chaque hôte. Cet indice était aussi expliqué par les mêmes variables (age, allaitement et voie d’accouchement) dans le même sens.

### Diversité au niveau phylogroupe

On va calculer le nombre de phylogroupe qu'a porté un hôte pendant la cohorte (et on le divise par le temps) pour estimer la diversité moyenne au niveau du phylogroupe.
On sélectionne le meilleur modèle linéaire par comparaison de AIC.

```{r phylo_div}
summary(best_lm_phylo_diversity)
Anova(best_lm_phylo_diversity)
```

Le meilleur modèle sélectionne le sexe, le régime et les évènements voyage et prise antibiotique. L'effet du régime est significatif. 

Le sens est le suivant : 

- Les femmes auraient moins de diversité moyenne au niveau du phylogroupe que les hommes (pvalue presque significative).
- Les hôtes au régime équilibré auraient moins de diversité que ceux ayant un régime fort en alcool (mais pvalue absolument pas significative).
- Les hôtes avec un régime haut en fibre auraient plus de diversité que ceux avec un régime fort en alcool (pvalue presque significative).
- Les hôtes ayant fait un voyage auraient moins de diversité au niveau phylogroupe.

### Beta-diversité chez un hôte et facteurs hôtes

On va voir la dissimilarité entre les samples consécutif chez un même hôte. Ceci est une mesure du renouvellement du microbiote des hôtes. 

On peut ainsi comparer les beta diversité entre les hôtes.

```{r betadiv_plot}
plot_mean_bc
```

On voit que les BC varient en fonction des hôtes. Certains ont en moyenne des BC plus faibles que d'autres indiquant une variabilité dans le renouvellement des souches chez chaque hôtes.

Les moyennes sont élevées (contrairement à celles dans le papier de Martinson). Ceci pourrait provenir du fait qu'on a plus de diversité en France et donc entre les samples on change beaucoup plus qu'aux US.

Si on moyenne les BC distance on peut les expliquer avec des facteurs hôtes. 

```{r lm_betadiv_mod}
summary(best_lm_bc)
Anova(best_lm_bc)
```

Les différences entre les BC en moyenne sont expliquées (dans le meilleur modèle) par le sexe (significatif), l'age, le poids, la voie d'accouchement, l'allaitement (significatif) et les évènements antibio/voyage (significatif).

Leur sens  : 

- Les femmes ont une distance de BC moyenne plus faible que les hommes (les femmes ont moins de renouvellement des E. coli, va dans le sens d'une plus longue persistance des souches et de la présence de certains phylogroupes résidents). 
- Plus une personne est vieille moins elle a de distance BC (ie plus on vieillit moins on a de renouvellement du microbiote au niveau des E. coli).
- Une personne non allaitée par sa mère à plus de turnover qu'une personne allaitée.
- Les personnes ayant consommées des antibiotiques ont une distance de BC moyenne plus faibles que ceux n'en ayant pas consommé. Ceci est étonnant : trace de résistance ? de sélection par les antibiotiques de souches résidentes ? hypothèse : les antibiotiques détruisent la diversité des E. coli et ne gardent que les souches résistantes qui dcp ne changent pas entre les samples et ceci baisse la moyenne de la distance BC.

On peut aussi faire la dissimilarité entre toutes les paires de samples et voir si plus les samples sont loin plus la BC augmente.

```{r betadiv_time, fig.height=45, fig.width=10}
plot_bc_time
```

La distance de BC augmente avec le temps dans la plupart des cas. Certains ne marchent pas très bien probablement en fonction de comment on sample. 

Les coefficients de spearman semblent similaires à ceux de Martinson. En revanche comme déjà observé, les BC sont plus hautes que chez Martinson, soit cela provient de la profondeur de sampling différente entre nos deux études, soit de la diversité qui est plus forte en France.

# Sauvegarde variables

```{r}
# Je save les objets pour qu'ils soient dispo plus tard et dans d'autres documents Rmd.
save(longitudinal_strain_host, longitudinal, longitudinal_strain, metadata, plot_distrib_residency, plot_distrib_residency_log_scaled, plot_residency_phylogroup, plot_residency_resident_phylogroup, plot_residency_resident_dens_self, plot_residency_dens_self, plot_residency_dens_glob, plot_residency_resident_dens_glob, plot_logresidency_sex, plot_logresidency_resident_sex, best_lm_residency, best_lm_logresidency, best_lm_residency_resident, plot_residency_status_phylogroup, plot_residency_status_dens_self, plot_residency_status_dens_glob, plot_residency_status_regime, plot_residency_status_age, plot_residency_status_age_group, best_glm_resident, plot_forest_or, plot_distrib_number_event, modele_selected_finaliteration, best_lm_diversity, plot_diversity_event, plot_mean_bc, best_turnover_lm, plot_turnover_age_group, plot_turnover_sex,file = "cohort_metadata.RData")
```